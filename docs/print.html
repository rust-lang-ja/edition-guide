<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Edition Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/em-to-bold.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">序文</a></li><li class="chapter-item expanded "><a href="editions/index.html"><strong aria-hidden="true">1.</strong> エディションとは？</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="editions/creating-a-new-project.html"><strong aria-hidden="true">1.1.</strong> 新しいプロジェクトを作成する</a></li><li class="chapter-item expanded "><a href="editions/transitioning-an-existing-project-to-a-new-edition.html"><strong aria-hidden="true">1.2.</strong> 既存のプロジェクトのエディションを移行する</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2015/index.html"><strong aria-hidden="true">2.</strong> Rust 2015</a></li><li class="chapter-item expanded "><a href="rust-2018/index.html"><strong aria-hidden="true">3.</strong> Rust 2018</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/edition-changes.html"><strong aria-hidden="true">3.1.</strong> 2018-Specific Changes</a></li><li class="chapter-item expanded "><a href="rust-2018/module-system/index.html"><strong aria-hidden="true">3.2.</strong> Module system</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/module-system/raw-identifiers.html"><strong aria-hidden="true">3.2.1.</strong> Raw identifiers</a></li><li class="chapter-item expanded "><a href="rust-2018/module-system/path-clarity.html"><strong aria-hidden="true">3.2.2.</strong> Path clarity</a></li><li class="chapter-item expanded "><a href="rust-2018/module-system/more-visibility-modifiers.html"><strong aria-hidden="true">3.2.3.</strong> More visibility modifiers</a></li><li class="chapter-item expanded "><a href="rust-2018/module-system/nested-imports-with-use.html"><strong aria-hidden="true">3.2.4.</strong> Nested imports with use</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2018/error-handling-and-panics/index.html"><strong aria-hidden="true">3.3.</strong> Error handling and panics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html"><strong aria-hidden="true">3.3.1.</strong> The ? operator for easier error handling</a></li><li class="chapter-item expanded "><a href="rust-2018/error-handling-and-panics/question-mark-in-main-and-tests.html"><strong aria-hidden="true">3.3.2.</strong> ? in main and tests</a></li><li class="chapter-item expanded "><a href="rust-2018/error-handling-and-panics/controlling-panics-with-std-panic.html"><strong aria-hidden="true">3.3.3.</strong> Controlling panics with std::panic</a></li><li class="chapter-item expanded "><a href="rust-2018/error-handling-and-panics/aborting-on-panic.html"><strong aria-hidden="true">3.3.4.</strong> Aborting on panic</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2018/control-flow/index.html"><strong aria-hidden="true">3.4.</strong> Control flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/control-flow/loops-can-break-with-a-value.html"><strong aria-hidden="true">3.4.1.</strong> Loops can break with a value</a></li><li class="chapter-item expanded "><a href="rust-2018/control-flow/async-await-for-easier-concurrency.html"><strong aria-hidden="true">3.4.2.</strong> async/await for easier concurrency</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2018/trait-system/index.html"><strong aria-hidden="true">3.5.</strong> Trait system</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html"><strong aria-hidden="true">3.5.1.</strong> impl Trait for returning complex types with ease</a></li><li class="chapter-item expanded "><a href="rust-2018/trait-system/dyn-trait-for-trait-objects.html"><strong aria-hidden="true">3.5.2.</strong> dyn Trait for trait objects</a></li><li class="chapter-item expanded "><a href="rust-2018/trait-system/more-container-types-support-trait-objects.html"><strong aria-hidden="true">3.5.3.</strong> More container types support trait objects</a></li><li class="chapter-item expanded "><a href="rust-2018/trait-system/associated-constants.html"><strong aria-hidden="true">3.5.4.</strong> Associated constants</a></li><li class="chapter-item expanded "><a href="rust-2018/trait-system/no-anon-params.html"><strong aria-hidden="true">3.5.5.</strong> No more anonymous parameters</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2018/slice-patterns.html"><strong aria-hidden="true">3.6.</strong> Slice patterns</a></li><li class="chapter-item expanded "><a href="rust-2018/ownership-and-lifetimes/index.html"><strong aria-hidden="true">3.7.</strong> Ownership and lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html"><strong aria-hidden="true">3.7.1.</strong> Non-lexical lifetimes</a></li><li class="chapter-item expanded "><a href="rust-2018/ownership-and-lifetimes/default-match-bindings.html"><strong aria-hidden="true">3.7.2.</strong> Default match bindings</a></li><li class="chapter-item expanded "><a href="rust-2018/ownership-and-lifetimes/the-anonymous-lifetime.html"><strong aria-hidden="true">3.7.3.</strong> '_, the anonymous lifetime</a></li><li class="chapter-item expanded "><a href="rust-2018/ownership-and-lifetimes/lifetime-elision-in-impl.html"><strong aria-hidden="true">3.7.4.</strong> Lifetime elision in impl</a></li><li class="chapter-item expanded "><a href="rust-2018/ownership-and-lifetimes/inference-in-structs.html"><strong aria-hidden="true">3.7.5.</strong> T: 'a inference in structs</a></li><li class="chapter-item expanded "><a href="rust-2018/ownership-and-lifetimes/simpler-lifetimes-in-static-and-const.html"><strong aria-hidden="true">3.7.6.</strong> Simpler lifetimes in static and const</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2018/data-types/index.html"><strong aria-hidden="true">3.8.</strong> Data types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/data-types/field-init-shorthand.html"><strong aria-hidden="true">3.8.1.</strong> Field init shorthand</a></li><li class="chapter-item expanded "><a href="rust-2018/data-types/inclusive-ranges.html"><strong aria-hidden="true">3.8.2.</strong> ..= for inclusive ranges</a></li><li class="chapter-item expanded "><a href="rust-2018/data-types/128-bit-integers.html"><strong aria-hidden="true">3.8.3.</strong> 128 bit integers</a></li><li class="chapter-item expanded "><a href="rust-2018/data-types/operator-equals-are-now-implementable.html"><strong aria-hidden="true">3.8.4.</strong> &quot;Operator-equals&quot; are now implementable</a></li><li class="chapter-item expanded "><a href="rust-2018/data-types/union-for-an-unsafe-form-of-enum.html"><strong aria-hidden="true">3.8.5.</strong> union for an unsafe form of enum</a></li><li class="chapter-item expanded "><a href="rust-2018/data-types/choosing-alignment-with-the-repr-attribute.html"><strong aria-hidden="true">3.8.6.</strong> Choosing alignment with the repr attribute</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2018/simd-for-faster-computing.html"><strong aria-hidden="true">3.9.</strong> SIMD for faster computing</a></li><li class="chapter-item expanded "><a href="rust-2018/macros/index.html"><strong aria-hidden="true">3.10.</strong> Macros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/macros/custom-derive.html"><strong aria-hidden="true">3.10.1.</strong> Custom Derive</a></li><li class="chapter-item expanded "><a href="rust-2018/macros/macro-changes.html"><strong aria-hidden="true">3.10.2.</strong> Macro changes</a></li><li class="chapter-item expanded "><a href="rust-2018/macros/at-most-once.html"><strong aria-hidden="true">3.10.3.</strong> At most one repetition</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2018/the-compiler/index.html"><strong aria-hidden="true">3.11.</strong> The compiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/the-compiler/improved-error-messages.html"><strong aria-hidden="true">3.11.1.</strong> Improved error messages</a></li><li class="chapter-item expanded "><a href="rust-2018/the-compiler/incremental-compilation-for-faster-compiles.html"><strong aria-hidden="true">3.11.2.</strong> Incremental Compilation for faster compiles</a></li><li class="chapter-item expanded "><a href="rust-2018/the-compiler/an-attribute-for-deprecation.html"><strong aria-hidden="true">3.11.3.</strong> An attribute for deprecation</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2018/rustup-for-managing-rust-versions.html"><strong aria-hidden="true">3.12.</strong> Rustup for managing Rust versions</a></li><li class="chapter-item expanded "><a href="rust-2018/cargo-and-crates-io/index.html"><strong aria-hidden="true">3.13.</strong> Cargo and crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/cargo-and-crates-io/cargo-check-for-faster-checking.html"><strong aria-hidden="true">3.13.1.</strong> cargo check for faster checking</a></li><li class="chapter-item expanded "><a href="rust-2018/cargo-and-crates-io/cargo-install-for-easy-installation-of-tools.html"><strong aria-hidden="true">3.13.2.</strong> cargo install for easy installation of tools</a></li><li class="chapter-item expanded "><a href="rust-2018/cargo-and-crates-io/cargo-new-defaults-to-a-binary-project.html"><strong aria-hidden="true">3.13.3.</strong> cargo new defaults to a binary project</a></li><li class="chapter-item expanded "><a href="rust-2018/cargo-and-crates-io/cargo-rustc-for-passing-arbitrary-flags-to-rustc.html"><strong aria-hidden="true">3.13.4.</strong> cargo rustc for passing arbitrary flags to rustc</a></li><li class="chapter-item expanded "><a href="rust-2018/cargo-and-crates-io/cargo-workspaces-for-multi-package-projects.html"><strong aria-hidden="true">3.13.5.</strong> Cargo workspaces for multi-package projects</a></li><li class="chapter-item expanded "><a href="rust-2018/cargo-and-crates-io/multi-file-examples.html"><strong aria-hidden="true">3.13.6.</strong> Multi-file examples</a></li><li class="chapter-item expanded "><a href="rust-2018/cargo-and-crates-io/replacing-dependencies-with-patch.html"><strong aria-hidden="true">3.13.7.</strong> Replacing dependencies with patch</a></li><li class="chapter-item expanded "><a href="rust-2018/cargo-and-crates-io/cargo-can-use-a-local-registry-replacement.html"><strong aria-hidden="true">3.13.8.</strong> Cargo can use a local registry replacement</a></li><li class="chapter-item expanded "><a href="rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html"><strong aria-hidden="true">3.13.9.</strong> Crates.io disallows wildcard dependencies</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2018/documentation/index.html"><strong aria-hidden="true">3.14.</strong> Documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/documentation/new-editions-of-the-book.html"><strong aria-hidden="true">3.14.1.</strong> New editions of the &quot;the book&quot;</a></li><li class="chapter-item expanded "><a href="rust-2018/documentation/the-rust-bookshelf.html"><strong aria-hidden="true">3.14.2.</strong> The Rust Bookshelf</a></li><li class="chapter-item expanded "><a href="rust-2018/documentation/the-rustonomicon.html"><strong aria-hidden="true">3.14.3.</strong> The Rustonomicon</a></li><li class="chapter-item expanded "><a href="rust-2018/documentation/std-os-has-documentation-for-all-platforms.html"><strong aria-hidden="true">3.14.4.</strong> Full documentation for std::os</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2018/rustdoc/index.html"><strong aria-hidden="true">3.15.</strong> rustdoc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/rustdoc/documentation-tests-can-now-compile-fail.html"><strong aria-hidden="true">3.15.1.</strong> Documentation tests can now compile-fail</a></li><li class="chapter-item expanded "><a href="rust-2018/rustdoc/rustdoc-uses-commonmark.html"><strong aria-hidden="true">3.15.2.</strong> Rustdoc uses CommonMark</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2018/platform-and-target-support/index.html"><strong aria-hidden="true">3.16.</strong> Platform and target support</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/platform-and-target-support/libcore-for-low-level-rust.html"><strong aria-hidden="true">3.16.1.</strong> libcore for low-level Rust</a></li><li class="chapter-item expanded "><a href="rust-2018/platform-and-target-support/webassembly-support.html"><strong aria-hidden="true">3.16.2.</strong> WebAssembly support</a></li><li class="chapter-item expanded "><a href="rust-2018/platform-and-target-support/global-allocators.html"><strong aria-hidden="true">3.16.3.</strong> Global allocators</a></li><li class="chapter-item expanded "><a href="rust-2018/platform-and-target-support/msvc-toolchain-support.html"><strong aria-hidden="true">3.16.4.</strong> MSVC toolchain support</a></li><li class="chapter-item expanded "><a href="rust-2018/platform-and-target-support/musl-support-for-fully-static-binaries.html"><strong aria-hidden="true">3.16.5.</strong> MUSL support for fully static binaries</a></li><li class="chapter-item expanded "><a href="rust-2018/platform-and-target-support/cdylib-crates-for-c-interoperability.html"><strong aria-hidden="true">3.16.6.</strong> cdylib crates for C interoperability</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="rust-next/index.html"><strong aria-hidden="true">4.</strong> 次のエディション</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-next/edition-changes.html"><strong aria-hidden="true">4.1.</strong> 次のエディションに特有の変更</a></li><li class="chapter-item expanded "><a href="rust-next/dbg-macro.html"><strong aria-hidden="true">4.2.</strong> dbg! マクロ</a></li><li class="chapter-item expanded "><a href="rust-next/no-jemalloc.html"><strong aria-hidden="true">4.3.</strong> デフォルトでjemallocを使わない</a></li><li class="chapter-item expanded "><a href="rust-next/uniform-paths.html"><strong aria-hidden="true">4.4.</strong> 統一的なパス</a></li><li class="chapter-item expanded "><a href="rust-next/literal-macro-matcher.html"><strong aria-hidden="true">4.5.</strong> リテラルマクロマッチャ</a></li><li class="chapter-item expanded "><a href="rust-next/qustion-mark-operator-in-macros.html"><strong aria-hidden="true">4.6.</strong> マクロ内の?演算子</a></li><li class="chapter-item expanded "><a href="rust-next/const-fn.html"><strong aria-hidden="true">4.7.</strong> const fn</a></li><li class="chapter-item expanded "><a href="rust-next/pin.html"><strong aria-hidden="true">4.8.</strong> ピン留め</a></li><li class="chapter-item expanded "><a href="rust-next/no-more-fnbox.html"><strong aria-hidden="true">4.9.</strong> FnBoxは不要に</a></li><li class="chapter-item expanded "><a href="rust-next/alternative-cargo-registries.html"><strong aria-hidden="true">4.10.</strong> Cargoレジストリが選択できるように</a></li><li class="chapter-item expanded "><a href="rust-next/tryfrom-and-tryinto.html"><strong aria-hidden="true">4.11.</strong> TryFromとTryInto</a></li><li class="chapter-item expanded "><a href="rust-next/future.html"><strong aria-hidden="true">4.12.</strong> Futureトレイト</a></li><li class="chapter-item expanded "><a href="rust-next/alloc.html"><strong aria-hidden="true">4.13.</strong> allocクレート</a></li><li class="chapter-item expanded "><a href="rust-next/maybe-uninit.html"><strong aria-hidden="true">4.14.</strong> MaybeUninit</a></li><li class="chapter-item expanded "><a href="rust-next/cargo-vendor.html"><strong aria-hidden="true">4.15.</strong> cargo vendor</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Edition Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#序文" id="序文">序文</a></h1>
<!-- # Introduction -->
<!-- Welcome to the Rust Edition Guide! "Editions" are Rust's way of -->
<!-- communicating large changes in the way that it feels to write Rust -->
<!-- code. -->
<p>Rust エディションガイドへようこそ！「エディション」とは、Rust でのコードの書き方
における重大な変化をあなたに伝えるためにあるものです。</p>
<!-- In this guide, we'll discuss: -->
<p>このガイドでは、下記の項目について説明します：</p>
<!-- * What editions are -->
<!-- * What each edition is about -->
<!-- * How to migrate your code from one edition to another -->
<ul>
<li>エディションとは何か</li>
<li>各エディションの内容</li>
<li>コードをあるエディションから別のエディションへ移行する方法</li>
</ul>
<!-- Note that the standard library grows with each Rust release; there are -->
<!-- *many* additions to the standard library that are not called out in -->
<!-- this guide. Only the major ones are, but there's tons of medium and -->
<!-- small things that are great too. You may want to check out [the -->
<!-- standard library documentation](https://doc.rust-lang.org/std/) as -->
<!-- well. -->
<p>Rust が新しくリリースされるとともに、標準ライブラリは発展します。標準ライブラリ
へ追加される機能のうち、重要なものだけがこのガイドに記載されていますが、記載は
ないものの、すばらしい機能も沢山追加されています。
<a href="https://doc.rust-lang.org/std/">標準ライブラリのドキュメンテーション</a>も是非
ご覧ください。</p>
<!--
# What are Editions?
-->
<h1><a class="header" href="#エディションとは" id="エディションとは">エディションとは？</a></h1>
<!--
Rust ships releases on a six-week cycle. This means that users get a constant
stream of new features. This is much faster than updates for other languages,
but this also means that each update is smaller.  After a while, all of those
tiny changes add up. But, from release to release, it can be hard to look back
and say *"Wow, between Rust 1.10 and Rust 1.20, Rust has changed a lot!"*
-->
<p>Rustは6週間ごとにリリースを行います。
これにより、ユーザーは新しい機能を常に手に入れることができます。
これは他の言語よりも速いサイクルですが、アップデートのサイズは小さくなります。
しばらくするとこれらの小変更が積み重なってきますが、いくつかのリリースを振り返って、「おお、バージョン1.10から1.20の間にRustは大きく変わったなぁ」と言うのは難しいかも知れません。</p>
<!--
Every two or three years, we'll be producing a new *edition* of Rust. Each
edition brings together the features that have landed into a clear package, with
fully updated documentation and tooling. New editions ship through the usual
release process.
-->
<p>2,3年に一度、Rustの新しい「エディション」を作成します。
各エディションはそれまでRustに加えられた変更をまとめ上げたもので、最新のドキュメントとツールもそれに含まれます。
新しいエディションは通常のリリースプロセスを経てリリースされます。</p>
<!--
This serves different purposes for different people:

- For active Rust users, it brings together incremental changes into an
  easy-to-understand package.

- For non-users, it signals that some major advancements have landed, which
  might make Rust worth another look.

- For those developing Rust itself, it provides a rallying point for the project as a
  whole.
  -->
<p>エディションは様々な人の異なる要求を満たします。</p>
<ul>
<li>
<p>Rustのアクティブなユーザーにとっては、6週間ごとににリリースされた機能変更をわかりやすくまとめたパッケージとなります。</p>
</li>
<li>
<p>Rustを使っていない人にとっては、大きな変更が施されたことを知らせる役割を果たし、それによってRustを使ってみようと思うようになるかも知れません。</p>
</li>
<li>
<p>Rustの内部開発者にとっては、プロジェクト全体の長期的なゴールになります。</p>
</li>
</ul>
<!--
## Compatibility
-->
<h2><a class="header" href="#互換性" id="互換性">互換性</a></h2>
<!--
When a new edition becomes available in the compiler, crates must explicitly opt
in to it to take full advantage. This opt in enables editions to contain
incompatible changes, like adding a new keyword that might conflict with
identifiers in code, or turning warnings into errors. A Rust compiler will
support all editions that existed prior to the compiler's release, and can link
crates of any supported editions together.
Edition changes only affect the way the compiler initially parses the code.
Therefore, if you're using Rust 2015, and
one of your dependencies uses Rust 2018, it all works just fine. The opposite
situation works as well.
-->
<p>新しいエディションがコンパイラで利用可能になった際に、その利点を最大限に活かすためには、クレートは明示的にオプトインする必要があります。
このオプトインはエディションに非互換の変更を加えるために必要で、例えば、既存のコードで使われている識別子と競合する新たなキーワードを導入したり、警告だったものをエラーにする、などの変更を加えることができるようになります。
Rustのコンパイラはこれまでの全てのエディションをサポートしていて、複数のクレートが異なるエディションを使用していても一つにリンクできます。
エディションの変更はコンパイラが最初にコードを構文解析する際の動作のみに影響します。
従って、例ばあなたがRust 2015を使っていて、依存するクレートが Rust 2018を使っていても全く問題なく動作します。
その逆の場合も同様です。</p>
<!--
Just to be clear: most features will be available on all editions.
People using any edition of Rust will continue to see improvements as new
stable releases are made.  In some cases however, mainly when new keywords are
added, but sometimes for other reasons, there may be new features that are only
available in later editions.  You only need to upgrade if you want to take
advantage of such features.
-->
<p>念の為はっきりさせておきますが、ほとんどの機能は全てのエディションで利用可能です。
どのエディションを利用していても、新たな安定板リリースが出た際には改善を見ることができます。
時折、例えば新たなキーワードが導入されたりその他の理由で、あるエディション以降でしか利用できない機能追加があります。
そのような機能を利用したい時にエディションのアップデートを検討するのが良いでしょう。</p>
<!--
# Creating a new project

When you create a new project with Cargo, it will automatically add
configuration for the latest edition:
-->
<h1><a class="header" href="#新しいプロジェクトを作成する" id="新しいプロジェクトを作成する">新しいプロジェクトを作成する</a></h1>
<p>Cargoは新たなプロジェクトを作成する際に自動で最新のエディションをコンフィギュレーションに追加します。</p>
<pre><code class="language-console">&gt; cargo +nightly new foo
     Created binary (application) `foo` project
&gt; cat .\foo\Cargo.toml
[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;your name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<!--
That `edition = "2018"` setting will configure your package to use Rust 2018.
No more configuration needed!

If you'd prefer to use an older edition, you can change the value in that
key, for example:
-->
<p>この <code>edition = &quot;2018&quot;</code> によってあなたのパッケージが Rust 2018 を利用するように設定されます。
これ以外は必要ありません。</p>
<p>もし、他の古いエディションを使いたい場合は、その設定の値を変更できます。例えば、</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;your name &lt;you@example.com&gt;&quot;]
edition = &quot;2015&quot;

[dependencies]
</code></pre>
<!--
This will build your package in Rust 2015.
-->
<p>とすると、あなたのパッケージは Rust 2015 でビルドされます。</p>
<!--
# Transitioning an existing project to a new edition
-->
<h1><a class="header" href="#既存のプロジェクトのエディションを移行する" id="既存のプロジェクトのエディションを移行する">既存のプロジェクトのエディションを移行する</a></h1>
<!--
New editions might change the way you write Rust – they add new syntax,
language, and library features, and also remove features. For example, `try`,
`async`, and `await` are keywords in Rust 2018, but not Rust 2015. If you
have a project that's using Rust 2015, and you'd like to use Rust 2018 for it
instead, there's a few steps that you need to take.
-->
<p>新たなエディションによってRustの書き方が変わるかも知れません。
新しい構文や新たなライブラリ機能の追加、そして時に機能の削除もあります。
例えば、<code>try</code>、<code>async</code>、<code>await</code>は Rust 2018ではキーワードですが、Rust 2015ではそうではありません。
もしあなたが Rust 2015のプロジェクトを持っていて、それを Rust 2018に移行したい場合には、やらなければならないことが幾つかあります。</p>
<!--
> It's our intention that the migration to new editions is as smooth an
> experience as possible. If it's difficult for you to upgrade to Rust 2018,
> we consider that a bug. If you run into problems with this process, please
> [file a bug](https://github.com/rust-lang/rust/issues/new). Thank you!
-->
<blockquote>
<p>我々は、新しいエディションへの移行をできるだけスムーズに行えるようにしたいと考えています。
もし、Rust 2018へアップグレードするのが大変な場合は、我々はそれをバグとみなします。
もし移行時に問題があった場合には<a href="https://github.com/rust-lang/rust/issues/new">バグ登録</a>してください。</p>
<p>訳注：Rustの日本語コミュニティもあります。
Slackを使用しており<a href="https://rust-jp.herokuapp.com/">こちら</a>から登録できます。</p>
</blockquote>
<!--
Here's an example. Imagine we have a crate that has this code in
`src/lib.rs`:
-->
<p>ここに例を挙げます。<code>src/lib.rs</code>に以下のコードがあるクレートがあるとします。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, Box&lt;Foo&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code uses an anonymous parameter, that `Box<Foo>`. This is [not
supported in Rust 2018](../rust-2018/trait-system/no-anon-params.md), and
so this would fail to compile. Let's get this code up to date!
-->
<p>このコードは <code>Box&lt;Foo&gt;</code>という無名パラメータを使用しています。
これは <a href="editions/../rust-2018/trait-system/no-anon-params.html">Rust 2018ではサポートされておらず</a>、コンパイルに失敗します。
このコードを更新してみましょう。</p>
<!--
## Updating your code to be compatible with the new edition
-->
<h2><a class="header" href="#あなたのコードを新しいエディションでコンパイルできるようにする" id="あなたのコードを新しいエディションでコンパイルできるようにする">あなたのコードを新しいエディションでコンパイルできるようにする</a></h2>
<!--
Your code may or may not use features that are incompatible with the new
edition. In order to help transition to Rust 2018, we've included a new
subcommand with Cargo. To start, let's run it:
-->
<p>あなたのコードは互換性のない機能を使っているかも知れないし、使っていないかも知れません。
Rust 2018への移行を助けるためにCargoに新しいサブコマンドを追加しました。
まず初めにそれを起動してみましょう。</p>
<pre><code class="language-console">&gt; cargo fix --edition
</code></pre>
<!--
This will check your code, and automatically fix any issues that it can.
Let's look at `src/lib.rs` again:
-->
<p>これはあなたのコードをチェックして、自動的に移行の問題を修正してくれます。
もう一度 <code>src/lib.rs</code>を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, _: Box&lt;Foo&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
It's re-written our code to introduce a parameter name for that trait object.
In this case, since it had no name, `cargo fix` will replace it with `_`,
which is conventional for unused variables.
-->
<p>トレイトオブジェクトのためのパラメータ名が追加された形でコードが書き換えられています。
この場合は、パラメータ名がなかったので、使用されていないパラメータの慣習に従って <code>_</code> を付加しています。</p>
<!--
`cargo fix` can't always fix your code automatically.
If `cargo fix` can't fix something, it will print the warning that it cannot fix
to the console. If you see one of these warnings, you'll have to update your code
manually. See the corresponding section of this guide for help, and if you have
problems, please seek help at the [user's forums](https://users.rust-lang.org/).
-->
<p><code>Cargo fix</code>は常に自動的にコードを修正してくれるわけではありません。
もし、<code>cargo fix</code>がコードを修正できない時にはコンソールに修正できなかったという警告を表示します。
その場合は手動でコードを修正してください。
助けが必要な時は、このガイドの対応するセクションを参照してください。
問題がある場合は、 <a href="https://users.rust-lang.org/">ユーザーフォーラム</a>で助けを求めてください。</p>
<!--
Keep running `cargo fix --edition` until you have no more warnings.
-->
<p>そして警告が出なくなるまで <code>cargo fix --edition</code> を繰り返し実行してください。</p>
<!--
Congrats! Your code is now valid in both Rust 2015 and Rust 2018!
-->
<p>おめでとうございます！ あなたのコードはRust 2015とRust 2018の双方で正しいコードになりました。</p>
<!--
## Enabling the new edition to use new features
-->
<h2><a class="header" href="#新機能を使うために新たなエディションを有効化する" id="新機能を使うために新たなエディションを有効化する">新機能を使うために新たなエディションを有効化する</a></h2>
<!--
In order to use some new features, you must explicitly opt in to the new
edition. Once you're ready to commit, change your `Cargo.toml` to add the new
`edition` key/value pair. For example:
-->
<p>新しいエディションの新機能を使うには明示的にオプトインする必要があります。
コミットする準備ができたら、<code>Cargo.toml</code>に新しいエディションのキーバリューペアを追加してください。
例えば以下のような形になります。</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;
</code></pre>
<!--
If there's no `edition` key, Cargo will default to Rust 2015. But in this case,
we've chosen `2018`, and so our code is compiling with Rust 2018!
-->
<p>もし <code>edition</code>キーがなければCargoはデフォルトで Rust 2015をエディションとして使います。
しかし上記の例では、<code>2018</code>を明示的に指定しているのでコードは Rust 2018でビルドされます。</p>
<!--
## Writing idiomatic code in a new edition
-->
<h2><a class="header" href="#新しいエディションで慣用的なコードを書く" id="新しいエディションで慣用的なコードを書く">新しいエディションで慣用的なコードを書く</a></h2>
<!--
Editions are not only about new features and removing old ones. In any programming
language, idioms change over time, and Rust is no exception. While old code
will continue to compile, it might be written with different idioms today.
-->
<p>エディションは新機能を追加したり機能を削除するだけのものではありません。
どのようなプログラミング言語でも、イディオム（プログラムの書き方のスタイル）は時と共に変化していきます。
Rustも例外ではありません。
古いスタイルのコードは引き続きコンパイル可能ですが、新しいエディションでは違った書き方で書いた方が良いかも知れません。</p>
<!--
Our sample code contains an outdated idiom. Here it is again:
-->
<p>我々のサンプルコードは古いスタイルを含んでいます。
もう一度ここにそのコードを示します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, _: Box&lt;Foo&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
In Rust 2018, it's considered idiomatic to use the [`dyn`
keyword](../rust-2018/trait-system/dyn-trait-for-trait-objects.md) for
trait objects.
-->
<p>Rust 2018では、トレイトオブジェクトに <a href="editions/../rust-2018/trait-system/dyn-trait-for-trait-objects.html"><code>dyn</code> キーワード</a> を付けるのが良いとされています。</p>
<!--
Eventually, we want `cargo fix` to fix all these idioms automatically in the same
manner we did for upgrading to the 2018 edition. **Currently,
though, the *"idiom lints"* are not ready for widespread automatic fixing.** The
compiler isn't making `cargo fix`-compatible suggestions in many cases right
now, and it is making incorrect suggestions in others. Enabling the idiom lints,
even with `cargo fix`, is likely to leave your crate either broken or with many
warnings still remaining.
-->
<p>いずれ、<code>cargo fix</code>によってこのようなイディオムの変更も、2018エディションへアップグレードしたときのように自動的に行いたいと考えています。
<strong>ただし今現在は、イディオムチェッカーが広範囲の自動修正をできるレベルにはなっていません。</strong>
今のところ、コンパイラは多くの場合 <code>cargo fix</code>互換のサジェスチョンを出さなかったり、間違ったサジェスチョンを出したりします。
<code>cargo fix</code>と共にイディオムチェッカーを有効にすると、おそらくはあなたのコードを壊してしまったり、多くの警告が残り続けるということになってしまいます。</p>
<!--
We have plans to make these idiom migrations a seamless part of the Rust 2018
experience, but we're not there yet. As a result the following instructions are
recommended only for the intrepid who are willing to work through a few
compiler/Cargo bugs!
-->
<p>Rust 2018の体験の一部として、シームレスなイディオム移行を提供する計画があります。
しかしまだそこには至っていません。
したがって、以下の手順はコンパイラやCargoのバグを乗り越えることを厭わない勇猛な方のみにお勧めします。</p>
<!--
With that out of the way, we can instruct Cargo to fix our code snippet with:
-->
<p>以上を踏まえたうえで、私たちのコード片をCargoに修正させてみましょう。</p>
<pre><code class="language-console">$ cargo fix --edition-idioms
</code></pre>
<!--
Afterwards, `src/lib.rs` looks like this:
-->
<p>実行後は <code>src/lib.rs</code>は以下のようになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, _: Box&lt;dyn Foo&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
We're now more idiomatic, and we didn't have to fix our code manually!
-->
<p>これでコードはより新しいスタイルになりました。
手修正する必要はありませんでした。</p>
<!--
Note that `cargo fix` may still not be able to automatically update our code.
If `cargo fix` can't fix something, it will print a warning to the console, and
you'll have to fix it manually.
-->
<p>なお、<code>cargo fix</code>はコードを自動的に改修することができない場合もあることを覚えておいてください。
その場合は <code>cargo fix</code>は警告メッセージを出すので、それを見て手動でコードを修正してください。</p>
<!--
As mentioned before, there are known bugs around the idiom lints which
means they're not all ready for prime time yet. You may get a scary-looking
warning to report a bug to Cargo, which happens whenever a fix proposed by
`rustc` actually caused code to stop compiling by accident. If you'd like `cargo
fix` to make as much progress as possible, even if it causes code to stop
compiling, you can execute:
-->
<p>上でも述べたようにイディオムチェッカーには幾つかわかっているバグがあり、まだ実践登用できるレベルではありません。
Cargoのバグレポートを出すようにという恐ろしげな警告を見るかも知れませんが、これは <code>rustc</code>によって提案された修正が誤ってコードをコンパイルできなくしてしまった時に起こります。
もしコンパイルが止まったとしても <code>cargo fix</code>を使ってできるだけ自動修正をしたい場合には以下のコマンドを使います。</p>
<pre><code class="language-console">$ cargo fix --edition-idioms --broken-code
</code></pre>
<!--
This will instruct `cargo fix` to apply automatic suggestions regardless of
whether they work or not. Like usual, you'll see the compilation result after
all fixes are applied. If you notice anything wrong or unusual, please feel free
to report an issue to Cargo and we'll help prioritize and fix it.
-->
<p>これは、動くかどうかは関係なく<code>cargo fix</code>に自動修正を行わせます。
全ての修正が適用された後にコードはコンパイルされてその結果を見ることができます。
もし何か間違いや異常に気がついた時は、お気軽にCargoにバグ報告してください。</p>
<!--
Enjoy the new edition!
-->
<p>それでは、新しいエディションをお楽しみください！</p>
<h1><a class="header" href="#rust-2015" id="rust-2015">Rust 2015</a></h1>
<!--
Rust 2015 has a theme of "stability". It commenced with the release of 1.0,
and is the "default edition". The edition system was conceived in late 2017,
but Rust 1.0 was released in May of 2015. As such, 2015 is the edition
that you get when you don't specify any particular edition, for backwards
compatibility reasons.
-->
<p>Rust 2015は「安定性」というテーマを掲げています。
このエディションはRust 1.0のリリースから始まり、デフォルトのエディションとなっています。
エディションの仕組み自体は2017年末に考案されましたが、Rust 1.0は2015年5月にリリースされていて、「2015」が特定のエディションを指定しなかった時のデフォルトになります。</p>
<!--
"Stability" is the theme of Rust 2015 because 1.0 marked a huge change in
Rust development. Previous to Rust 1.0, Rust was changing on a daily basis.
This made it very difficult to write large software in Rust, and made it
difficult to learn. With the release of Rust 1.0 and Rust 2015, we committed
to backwards compatibility, ensuring a solid foundation for people to build
projects on top of.
-->
<p>「安定性」がRust 2015エディションのテーマです。
なぜなら、Rust 1.0はRust開発に著しい変化をもたらしたからです。
Rust 1.0以前は、Rustは毎日のように変わっていました。
そのような言語は大規模なソフトウエア開発には使えないですし、学ぶことも難しいでしょう。
Rust 1.0とRust 2015エディションの登場とともに、我々は後方互換性にコミットし、Rust上で開発を行う人々のための強固な基盤を提供しています。</p>
<!--
Since it's the default edition, there's no way to port your code to Rust
2015; it just *is*. You'll be transitioning *away* from 2015, but never
really *to* 2015. As such, there's not much else to say about it!
-->
<p>Rust 2015はデフォルトのエディションなのであなたのコードをRust 2015へポーティングするということはありません。
どんなRustのコードもRust 2015<em>です</em>。
あなたは Rust 2015から<em>離れる</em>ことはあっても、<em>近づいていく</em>ということはありません。
ということで、これ以上あまり言うことはないでしょう！</p>
<h1><a class="header" href="#rust-2018" id="rust-2018">Rust 2018</a></h1>
<p>The edition system was created for the release of Rust 2018. The theme of Rust 2018
is <em>productivity</em>. Rust 2018 improves upon Rust 2015 through new features,
simpler syntax in some cases, a smarter borrow-checker, and a host of other things.
These are all in service of the productivity goal. Rust 2015 was a foundation;
Rust 2018 smooths off rough edges, makes writing code simpler and easier,
and removes some inconsistencies.</p>
<h1><a class="header" href="#2018-specific-changes" id="2018-specific-changes">2018-Specific Changes</a></h1>
<p>The following is a summary of changes that only apply to code compiled with
the 2018 edition compared to the 2015 edition.</p>
<ul>
<li><a href="rust-2018/module-system/path-clarity.html">Path changes</a>:
<ul>
<li>Paths in <code>use</code> declarations work the same as other paths.</li>
<li>Paths starting with <code>::</code> must be followed with an external crate.</li>
<li>Paths in <code>pub(in path)</code> visibility modifiers must start with <code>crate</code>,
<code>self</code>, or <code>super</code>.</li>
</ul>
</li>
<li><a href="rust-2018/trait-system/no-anon-params.html">Anonymous trait function parameters</a> are not allowed.
<ul>
<li><a href="https://doc.rust-lang.org/stable/reference/items/traits.html#parameter-patterns">Trait function parameters</a> may use any irrefutable pattern when the
function has a body.</li>
</ul>
</li>
<li>Keyword changes:
<ul>
<li><a href="rust-2018/trait-system/dyn-trait-for-trait-objects.html"><code>dyn</code></a> is a <a href="https://doc.rust-lang.org/reference/keywords.html#strict-keywords">strict keyword</a>, in 2015 it is a <a href="https://doc.rust-lang.org/reference/keywords.html#weak-keywords">weak keyword</a>.</li>
<li><code>async</code> and <code>await</code> are <a href="https://doc.rust-lang.org/reference/keywords.html#strict-keywords">strict keywords</a>.</li>
<li><code>try</code> is a <a href="https://doc.rust-lang.org/reference/keywords.html#reserved-keywords">reserved keyword</a>.</li>
</ul>
</li>
<li>The following lints are now a hard error that you cannot silence:
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/46906">tyvar_behind_raw_pointer</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#cargo" id="cargo">Cargo</a></h2>
<ul>
<li>If there is a target definition in a <code>Cargo.toml</code> manifest, it no longer
automatically disables automatic discovery of other targets.</li>
<li>Target paths of the form <code>src/{target_name}.rs</code> are no longer inferred for
targets where the <code>path</code> field is not set.</li>
<li><code>cargo install</code> for the current directory is no longer allowed, you must
specify <code>cargo install --path .</code> to install the current package.</li>
</ul>
<h1><a class="header" href="#module-system" id="module-system">Module system</a></h1>
<p>In this chapter of the guide, we discuss a few changes to the module system.
The most notable of these are the <a href="rust-2018/module-system/path-clarity.html">path clarity changes</a>.</p>
<h1><a class="header" href="#raw-identifiers" id="raw-identifiers">Raw identifiers</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.30-brightgreen.svg" alt="Minimum Rust version: 1.30" /></p>
<p>Rust, like many programming languages, has the concept of &quot;keywords&quot;.
These identifiers mean something to the language, and so you cannot use them in
places like variable names, function names, and other places.
Raw identifiers let you use keywords where they would not normally be allowed.</p>
<p>For example, <code>match</code> is a keyword. If you try to compile this function:</p>
<pre><code class="language-rust ignore">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>You'll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>You can write this with a raw identifier:</p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>Note the <code>r#</code> prefix on both the function name as well as the call.</p>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>This feature is useful for a few reasons, but the primary motivation was
inter-edition situations. For example, <code>try</code> is not a keyword in the 2015
edition, but is in the 2018 edition. So if you have a library that is written
in Rust 2015 and has a <code>try</code> function, to call it in Rust 2018, you'll need
to use the raw identifier.</p>
<h2><a class="header" href="#new-keywords" id="new-keywords">New keywords</a></h2>
<p>The new confirmed keywords in edition 2018 are:</p>
<h3><a class="header" href="#async-and-await" id="async-and-await"><code>async</code> and <code>await</code></a></h3>
<p>Here, <code>async</code> is reserved for use in <code>async fn</code> as well as in <code>async ||</code> closures and
<code>async { .. }</code> blocks. Meanwhile, <code>await</code> is reserved to keep our options open
with respect to <code>await!(expr)</code> syntax. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2394-async_await.md#final-syntax-for-the-await-expression">RFC 2394</a> for more details.</p>
<h3><a class="header" href="#try" id="try"><code>try</code></a></h3>
<p>The <code>do catch { .. }</code> blocks have been renamed to <code>try { .. }</code> and to support
that, the keyword <code>try</code> is reserved in edition 2018.
See <a href="https://github.com/rust-lang/rfcs/pull/2388">RFC 2388</a> for more details.</p>
<h1><a class="header" href="#path-clarity" id="path-clarity">Path clarity</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<p>The module system is often one of the hardest things for people new to Rust. Everyone
has their own things that take time to master, of course, but there's a root
cause for why it's so confusing to many: while there are simple and
consistent rules defining the module system, their consequences can feel
inconsistent, counterintuitive and mysterious.</p>
<p>As such, the 2018 edition of Rust introduces a few new module system
features, but they end up <em>simplifying</em> the module system, to make it more
clear as to what is going on.</p>
<p>Here's a brief summary:</p>
<ul>
<li><code>extern crate</code> is no longer needed in 99% of circumstances.</li>
<li>The <code>crate</code> keyword refers to the current crate.</li>
<li>Paths may start with a crate name, even within submodules.</li>
<li>Paths starting with <code>::</code> must reference an external crate.</li>
<li>A <code>foo.rs</code> and <code>foo/</code> subdirectory may coexist; <code>mod.rs</code> is no longer needed
when placing submodules in a subdirectory.</li>
<li>Paths in <code>use</code> declarations work the same as other paths.</li>
</ul>
<p>These may seem like arbitrary new rules when put this way, but the mental
model is now significantly simplified overall. Read on for more details!</p>
<h2><a class="header" href="#more-details" id="more-details">More details</a></h2>
<p>Let's talk about each new feature in turn.</p>
<h3><a class="header" href="#no-more-extern-crate" id="no-more-extern-crate">No more <code>extern crate</code></a></h3>
<p>This one is quite straightforward: you no longer need to write <code>extern crate</code> to
import a crate into your project. Before:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

mod submodule {
    use futures::Future;
}
</code></pre>
<p>After:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;
}
</code></pre>
<p>Now, to add a new crate to your project, you can add it to your <code>Cargo.toml</code>,
and then there is no step two. If you're not using Cargo, you already had to pass
<code>--extern</code> flags to give <code>rustc</code> the location of external crates, so you'd just
keep doing what you were doing there as well.</p>
<blockquote>
<p>One small note here: <code>cargo fix</code> will not currently automate this change. We may
have it do this for you in the future.</p>
</blockquote>
<h4><a class="header" href="#an-exception" id="an-exception">An exception</a></h4>
<p>There's one exception to this rule, and that's the &quot;sysroot&quot; crates. These are the
crates distributed with Rust itself.</p>
<p>Usually these are only needed in very specialized situations. Starting in
1.41, <code>rustc</code> accepts the <code>--extern=CRATE_NAME</code> flag which automatically adds
the given crate name in a way similar to <code>extern crate</code>. Build tools may use
this to inject sysroot crates into the crate's prelude. Cargo does not have a
general way to express this, though it uses it for <code>proc_macro</code> crates.</p>
<p>Some examples of needing to explicitly import sysroot crates are:</p>
<ul>
<li><a href="rust-2018/module-system/../../../std/index.html"><code>std</code></a>: Usually this is not neccesary, because <code>std</code> is automatically
imported unless the crate is marked with <a href="rust-2018/module-system/../../../reference/crates-and-source-files.html#preludes-and-no_std"><code>#![no_std]</code></a>.</li>
<li><a href="rust-2018/module-system/../../../core/index.html"><code>core</code></a>: Usually this is not necessary, because <code>core</code> is automatically
imported, unless the crate is marked with <a href="https://github.com/rust-lang/rust/issues/29639"><code>#![no_core]</code></a>. For
example, some of the internal crates used by the standard library itself
need this.</li>
<li><a href="rust-2018/module-system/../../../proc_macro/index.html"><code>proc_macro</code></a>: This is automatically imported by Cargo if it is a
proc-macro crate starting in 1.42. <code>extern crate proc_macro;</code> would be
needed if you want to support older releases, or if using another build tool
that does not pass the appropriate <code>--extern</code> flags to <code>rustc</code>.</li>
<li><a href="rust-2018/module-system/../../../alloc/index.html"><code>alloc</code></a>: Items in the <code>alloc</code> crate are usually accessed via re-exports in
the <code>std</code> crate. If you are working with a <code>no_std</code> crate that supports
allocation, then you may need to explicitly import <code>alloc</code>.</li>
<li><a href="rust-2018/module-system/../../../test/index.html"><code>test</code></a>: This is only available on the <a href="rust-2018/module-system/../../../book/appendix-07-nightly-rust.html">nightly channel</a>, and is usually
only used for the unstable benchmark support.</li>
</ul>
<h4><a class="header" href="#macros" id="macros">Macros</a></h4>
<p>One other use for <code>extern crate</code> was to import macros; that's no longer needed.
Check <a href="rust-2018/module-system/../macros/macro-changes.html">the macro section</a> for more.</p>
<h4><a class="header" href="#renaming-crates" id="renaming-crates">Renaming crates</a></h4>
<p>If you've been using <code>as</code> to rename your crate like this:</p>
<pre><code class="language-rust ignore">extern crate futures as f;

use f::Future;
</code></pre>
<p>then removing the <code>extern crate</code> line on its own won't work. You'll need to do this:</p>
<pre><code class="language-rust ignore">use futures as f;

use self::f::Future;
</code></pre>
<p>This change will need to happen in any module that uses <code>f</code>.</p>
<h3><a class="header" href="#the-crate-keyword-refers-to-the-current-crate" id="the-crate-keyword-refers-to-the-current-crate">The <code>crate</code> keyword refers to the current crate</a></h3>
<p>In <code>use</code> declarations and in other code, you can refer to the root of the
current crate with the <code>crate::</code> prefix. For instance, <code>crate::foo::bar</code> will
always refer to the name <code>bar</code> inside the module <code>foo</code>, from anywhere else in
the same crate.</p>
<p>The prefix <code>::</code> previously referred to either the crate root or an external
crate; it now unambiguously refers to an external crate. For instance,
<code>::foo::bar</code> always refers to the name <code>bar</code> inside the external crate <code>foo</code>.</p>
<h3><a class="header" href="#extern-crate-paths" id="extern-crate-paths">Extern crate paths</a></h3>
<p>Previously, using an external crate in a module without a <code>use</code> import
required a leading <code>::</code> on the path.</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate chrono;

fn foo() {
    // this works in the crate root
    let x = chrono::Utc::now();
}

mod submodule {
    fn function() {
        // but in a submodule it requires a leading :: if not imported with `use`
        let x = ::chrono::Utc::now();
    }
}
</code></pre>
<p>Now, extern crate names are in scope in the entire crate, including
submodules.</p>
<pre><code class="language-rust ignore">// Rust 2018

fn foo() {
    // this works in the crate root
    let x = chrono::Utc::now();
}

mod submodule {
    fn function() {
        // crates may be referenced directly, even in submodules
        let x = chrono::Utc::now();
    }
}
</code></pre>
<h3><a class="header" href="#no-more-modrs" id="no-more-modrs">No more <code>mod.rs</code></a></h3>
<p>In Rust 2015, if you have a submodule:</p>
<pre><code class="language-rust ignore">// This `mod` declaration looks for the `foo` module in
// `foo.rs` or `foo/mod.rs`.
mod foo;
</code></pre>
<p>It can live in <code>foo.rs</code> or <code>foo/mod.rs</code>. If it has submodules of its own, it
<em>must</em> be <code>foo/mod.rs</code>. So a <code>bar</code> submodule of <code>foo</code> would live at
<code>foo/bar.rs</code>.</p>
<p>In Rust 2018 the restriction that a module with submodules must be named
<code>mod.rs</code> is lifted. <code>foo.rs</code> can just be <code>foo.rs</code>,
and the submodule is still <code>foo/bar.rs</code>. This eliminates the special
name, and if you have a bunch of files open in your editor, you can clearly
see their names, instead of having a bunch of tabs named <code>mod.rs</code>.</p>
<table>
  <thead>
    <tr>
      <th>Rust 2015</th>
      <th>Rust 2018</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
<pre>
.
├── lib.rs
└── foo/
    ├── mod.rs
    └── bar.rs
</pre>
    </td>
    <td>
<pre>
.
├── lib.rs
├── foo.rs
└── foo/
    └── bar.rs
</pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><a class="header" href="#use-paths" id="use-paths"><code>use</code> paths</a></h3>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<p>Rust 2018 simplifies and unifies path handling compared to Rust 2015. In Rust
2015, paths work differently in <code>use</code> declarations than they do elsewhere. In
particular, paths in <code>use</code> declarations would always start from the crate
root, while paths in other code implicitly started from the current scope.
Those differences didn't have any effect in the top-level module, which meant
that everything would seem straightforward until working on a project large
enough to have submodules.</p>
<p>In Rust 2018, paths in <code>use</code> declarations and in other code work the same way,
both in the top-level module and in any submodule. You can use a relative path
from the current scope, a path starting from an external crate name, or a path
starting with <code>crate</code>, <code>super</code>, or <code>self</code>.</p>
<p>Code that looked like this:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>will look exactly the same in Rust 2018, except that you can delete the <code>extern crate</code> line:</p>
<pre><code class="language-rust ignore">// Rust 2018

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>The same code will also work completely unmodified in a submodule:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;

    mod foo {
        pub struct Bar;
    }

    use foo::Bar;

    fn my_poll() -&gt; futures::Poll { ... }

    enum SomeEnum {
        V1(usize),
        V2(String),
    }

    fn func() {
        let five = std::sync::Arc::new(5);
        use SomeEnum::*;
        match ... {
            V1(i) =&gt; { ... }
            V2(s) =&gt; { ... }
        }
    }
}
</code></pre>
<p>This makes it easy to move code around in a project, and avoids introducing
additional complexity to multi-module projects.</p>
<p>If a path is ambiguous, such as if you have an external crate and a local
module or item with the same name, you'll get an error, and you'll need to
either rename one of the conflicting names or explicitly disambiguate the path.
To explicitly disambiguate a path, use <code>::name</code> for an external crate name, or
<code>self::name</code> for a local module or item.</p>
<h1><a class="header" href="#more-visibility-modifiers" id="more-visibility-modifiers">More visibility modifiers</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.18-brightgreen.svg" alt="Minimum Rust version: 1.18" /></p>
<p>You can use the <code>pub</code> keyword to make something a part of a module's public interface. But in
addition, there are some new forms:</p>
<pre><code class="language-rust ignore">pub(crate) struct Foo;

pub(in a::b::c) struct Bar;
</code></pre>
<p>The first form makes the <code>Foo</code> struct public to your entire crate, but not
externally. The second form is similar, but makes <code>Bar</code> public for one other
module, <code>a::b::c</code> in this case.</p>
<h1><a class="header" href="#nested-imports-with-use" id="nested-imports-with-use">Nested imports with <code>use</code></a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p>A new way to write <code>use</code> statements has been added to Rust: nested import
groups. If you’ve ever written a set of imports like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
<span class="boring">}
</span></code></pre></pre>
<p>You can now write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod foo {
</span>// on one line
use std::{fs::File, io::Read, path::{Path, PathBuf}};
<span class="boring">}
</span>
<span class="boring">mod bar {
</span>// with some more breathing room
use std::{
    fs::File,
    io::Read,
    path::{
        Path,
        PathBuf
    }
};
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>This can reduce some repetition, and make things a bit more clear.</p>
<h1><a class="header" href="#error-handling-and-panics" id="error-handling-and-panics">Error handling and Panics</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to error handling
in Rust. The most notable of these is <a href="rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">the introduction of the <code>?</code> operator</a>.</p>
<h1><a class="header" href="#the--operator-for-easier-error-handling" id="the--operator-for-easier-error-handling">The <code>?</code> operator for easier error handling</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.13-brightgreen.svg" alt="Minimum Rust version: 1.13" /> for <code>Result&lt;T, E&gt;</code></p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.22-brightgreen.svg" alt="Minimum Rust version: 1.22" /> for <code>Option&lt;T&gt;</code></p>
<p>Rust has gained a new operator, <code>?</code>, that makes error handling more pleasant
by reducing the visual noise involved. It does this by solving one simple
problem. To illustrate, imagine we had some code to read some data from a
file:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{io::{self, prelude::*}, fs::File};
</span>fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;username.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: this code could be made simpler with a single call to
<a href="https://doc.rust-lang.org/stable/std/fs/fn.read_to_string.html"><code>std::fs::read_to_string</code></a>,
but we're writing it all out manually here to have an example with multiple
errors.</p>
</blockquote>
<p>This code has two paths that can fail, opening the file and reading the data
from it. If either of these fail to work, we'd like to return an error from
<code>read_username_from_file</code>. Doing so involves <code>match</code>ing on the result of the
I/O operations. In simple cases like this though, where we are only
propagating errors up the call stack, the matching is just boilerplate -
seeing it written out, in the same pattern every time, doesn't provide the
reader with a great deal of useful information.</p>
<p>With <code>?</code>, the above code looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{io::{self, prelude::*}, fs::File};
</span>fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;username.txt&quot;)?;
    let mut s = String::new();

    f.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>?</code> is shorthand for the entire match statements we wrote earlier. In
other words, <code>?</code> applies to a <code>Result</code> value, and if it was an <code>Ok</code>, it
unwraps it and gives the inner value. If it was an <code>Err</code>, it returns from the
function you're currently in. Visually, it is much more straightforward.
Instead of an entire match statement, now we are just using the single &quot;?&quot;
character to indicate that here we are handling errors in the standard way,
by passing them up the call stack.</p>
<p>Seasoned Rustaceans may recognize that this is the same as the <code>try!</code> macro
that's been available since Rust <code>1.0</code>. And indeed, they are the same.
Previously, <code>read_username_from_file</code> could have been implemented like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{io::{self, prelude::*}, fs::File};
</span>fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = try!(File::open(&quot;username.txt&quot;));
    let mut s = String::new();

    try!(f.read_to_string(&amp;mut s));

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p>So why extend the language when we already have a macro? There are multiple
reasons. First, <code>try!</code> has proved to be extremely useful, and is used often
in idiomatic Rust. It is used so often that we think it's worth having a
sweet syntax. This sort of evolution is one of the great advantages of a
powerful macro system: speculative extensions to the language syntax can be
prototyped and iterated on without modifying the language itself, and in
return, macros that turn out to be especially useful can indicate missing
language features. This evolution, from <code>try!</code> to <code>?</code> is a great example.</p>
<p>One of the reasons <code>try!</code> needs a sweeter syntax is that it is quite
unattractive when multiple invocations of <code>try!</code> are used in succession.
Consider:</p>
<pre><code class="language-rust ignore">try!(try!(try!(foo()).bar()).baz())
</code></pre>
<p>as opposed to</p>
<pre><code class="language-rust ignore">foo()?.bar()?.baz()?
</code></pre>
<p>The first is quite difficult to scan visually, and each layer of error
handling prefixes the expression with an additional call to <code>try!</code>. This
brings undue attention to the trivial error propagation, obscuring the main
code path, in this example the calls to <code>foo</code>, <code>bar</code> and <code>baz</code>. This sort of
method chaining with error handling occurs in situations like the builder
pattern.</p>
<p>Finally, the dedicated syntax will make it easier in the future to produce
nicer error messages tailored specifically to <code>?</code>, whereas it is difficult to
produce nice errors for macro-expanded code generally.</p>
<p>You can use <code>?</code> with <code>Result&lt;T, E&gt;</code>s, but also with <code>Option&lt;T&gt;</code>. In that
case, <code>?</code> will return a value for <code>Some(T)</code> and return <code>None</code> for <code>None</code>. One
current restriction is that you cannot use <code>?</code> for both in the same function,
as the return type needs to match the type you use <code>?</code> on. In the future,
this restriction will be lifted.</p>
<h1><a class="header" href="#-in-main-and-tests" id="-in-main-and-tests"><code>?</code> in <code>main</code> and tests</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Rust's error handling revolves around returning <code>Result&lt;T, E&gt;</code> and using <code>?</code>
to propagate errors. For those who write many small programs and, hopefully,
many tests, one common paper cut has been mixing entry points such as <code>main</code>
and <code>#[test]</code>s with error handling.</p>
<p>As an example, you might have tried to write:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;bar.txt&quot;)?;
}
</code></pre>
<p>Since <code>?</code> works by propagating the <code>Result</code> with an early return to the
enclosing function, the snippet above does not work, and results today
in the following error:</p>
<pre><code class="language-rust ignore">error[E0277]: the `?` operator can only be used in a function that returns `Result`
              or `Option` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:5:13
  |
5 |     let f = File::open(&quot;bar.txt&quot;)?;
  |             ^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>To solve this problem in Rust 2015, you might have written something like:</p>
<pre><pre class="playground"><code class="language-rust">// Rust 2015

<span class="boring">use std::process;
</span><span class="boring">use std::error::Error;
</span>
fn run() -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // real logic..
    Ok(())
}

fn main() {
    if let Err(e) = run() {
        println!(&quot;Application error: {}&quot;, e);
        process::exit(1);
    }
}
</code></pre></pre>
<p>However, in this case, the <code>run</code> function has all the interesting logic and
<code>main</code> is just boilerplate. The problem is even worse for <code>#[test]</code>s, since
there tend to be a lot more of them.</p>
<p>In Rust 2018 you can instead let your <code>#[test]</code>s and <code>main</code> functions return
a <code>Result</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run">// Rust 2018

use std::fs::File;

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let f = File::open(&quot;bar.txt&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>In this case, if say the file doesn't exist and there is an <code>Err(err)</code> somewhere,
then <code>main</code> will exit with an error code (not <code>0</code>) and print out a <code>Debug</code>
representation of <code>err</code>. Note that this will always print out the <code>Debug</code> representation.
If you would like to, for example, print out the <code>Display</code> representation of <code>err</code>, 
you will still have to do what you would in Rust 2015. </p>
<h2><a class="header" href="#more-details-1" id="more-details-1">More details</a></h2>
<p>Getting <code>-&gt; Result&lt;..&gt;</code> to work in the context of <code>main</code> and <code>#[test]</code>s is not
magic. It is all backed up by a <code>Termination</code> trait which all valid return
types of <code>main</code> and testing functions must implement. The trait is defined as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Termination {
    fn report(self) -&gt; i32;
}
<span class="boring">}
</span></code></pre></pre>
<p>When setting up the entry point for your application, the compiler will use this
trait and call <code>.report()</code> on the <code>Result</code> of the <code>main</code> function you have written.</p>
<p>Two simplified example implementations of this trait for <code>Result</code> and <code>()</code> are:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(process_exitcode_placeholder, termination_trait_lib)]
</span><span class="boring">use std::process::ExitCode;
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">pub trait Termination { fn report(self) -&gt; i32; }
</span>
impl Termination for () {
    fn report(self) -&gt; i32 {
<span class="boring">        use std::process::Termination;
</span>        ExitCode::SUCCESS.report()
    }
}

impl&lt;E: fmt::Debug&gt; Termination for Result&lt;(), E&gt; {
    fn report(self) -&gt; i32 {
        match self {
            Ok(()) =&gt; ().report(),
            Err(err) =&gt; {
                eprintln!(&quot;Error: {:?}&quot;, err);
<span class="boring">                use std::process::Termination;
</span>                ExitCode::FAILURE.report()
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see in the case of <code>()</code>, a success code is simply returned.
In the case of <code>Result</code>, the success case delegates to the implementation for
<code>()</code> but prints out an error message and a failure exit code on <code>Err(..)</code>.</p>
<p>To learn more about the finer details, consult either <a href="https://github.com/rust-lang/rust/issues/43301">the tracking issue</a> or <a href="https://github.com/rust-lang/rfcs/blob/master/text/1937-ques-in-main.md">the RFC</a>.</p>
<h1><a class="header" href="#controlling-panics-with-stdpanic" id="controlling-panics-with-stdpanic">Controlling panics with <code>std::panic</code></a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.9-brightgreen.svg" alt="Minimum Rust version: 1.9" /></p>
<p>There is a <code>std::panic</code> module, which includes methods for halting the
unwinding process started by a panic:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::panic;

let result = panic::catch_unwind(|| {
    println!(&quot;hello!&quot;);
});
assert!(result.is_ok());

let result = panic::catch_unwind(|| {
    panic!(&quot;oh no!&quot;);
});
assert!(result.is_err());
<span class="boring">}
</span></code></pre></pre>
<p>In general, Rust distinguishes between two ways that an operation can fail:</p>
<ul>
<li>Due to an <em>expected problem</em>, like a file not being found.</li>
<li>Due to an <em>unexpected problem</em>, like an index being out of bounds for an array.</li>
</ul>
<p>Expected problems usually arise from conditions that are outside of your
control; robust code should be prepared for anything its environment might throw
at it. In Rust, expected problems are handled via <a href="http://doc.rust-lang.org/std/result/index.html">the <code>Result</code> type</a>,
which allows a function to return information about the problem to its caller,
which can then handle the error in a fine-grained way.</p>
<p>Unexpected problems are <em>bugs</em>: they arise due to a contract or assertion being
violated. Since they are unexpected, it doesn't make sense to handle them in a
fine-grained way. Instead, Rust employs a &quot;fail fast&quot; approach by <em>panicking</em>,
which by default unwinds the stack (running destructors but no other code) of
the thread which discovered the error. Other threads continue running, but will
discover the panic any time they try to communicate with the panicked thread
(whether through channels or shared memory). Panics thus abort execution up to
some &quot;isolation boundary&quot;, with code on the other side of the boundary still
able to run, and perhaps to &quot;recover&quot; from the panic in some very coarse-grained
way. A server, for example, does not necessarily need to go down just because of
an assertion failure in one of its threads.</p>
<p>It's also worth noting that programs may choose to <em>abort</em> instead of unwind,
and so catching panics may not work. If your code relies on <code>catch_unwind</code>, you
should add this to your Cargo.toml:</p>
<pre><code class="language-toml">[profile.dev]
panic = &quot;unwind&quot;

[profile.release]
panic = &quot;unwind&quot;
</code></pre>
<p>If any of your users choose to abort, they'll get a compile-time failure.</p>
<p>The <code>catch_unwind</code> API offers a way to introduce new isolation boundaries
<em>within a thread</em>. There are a couple of key motivating examples:</p>
<ul>
<li>Embedding Rust in other languages</li>
<li>Abstractions that manage threads</li>
<li>Test frameworks, because tests may panic and you don't want that to kill the test runner</li>
</ul>
<p>For the first case, unwinding across a language boundary is undefined behavior,
and often leads to segfaults in practice. Allowing panics to be caught means
that you can safely expose Rust code via a C API, and translate unwinding into
an error on the C side.</p>
<p>For the second case, consider a threadpool library. If a thread in the pool
panics, you generally don't want to kill the thread itself, but rather catch the
panic and communicate it to the client of the pool. The <code>catch_unwind</code> API is
paired with <code>resume_unwind</code>, which can then be used to restart the panicking
process on the client of the pool, where it belongs.</p>
<p>In both cases, you're introducing a new isolation boundary within a thread, and
then translating the panic into some other form of error elsewhere.</p>
<h1><a class="header" href="#aborting-on-panic" id="aborting-on-panic">Aborting on panic</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.10-brightgreen.svg" alt="Minimum Rust version: 1.10" /></p>
<p>By default, Rust programs will unwind the stack when a <code>panic!</code> happens. If you'd prefer an
immediate abort instead, you can configure this in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;
</code></pre>
<p>Why might you choose to do this? By removing support for unwinding, you'll
get smaller binaries. You will lose the ability to catch panics. Which choice
is right for you depends on exactly what you're doing.</p>
<h1><a class="header" href="#control-flow" id="control-flow">Control flow</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to control flow.
The most notable of these <em>will</em> be <a href="rust-2018/control-flow/async-await-for-easier-concurrency.html"><code>async</code> and <code>await</code></a>.</p>
<h1><a class="header" href="#loops-can-break-with-a-value" id="loops-can-break-with-a-value"><code>loop</code>s can break with a value</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.19-brightgreen.svg" alt="Minimum Rust version: 1.19" /></p>
<p><code>loop</code>s can now break with a value:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// old code
let x;

loop {
    x = 7;
    break;
}

// new code
let x = loop { break 7; };
<span class="boring">}
</span></code></pre></pre>
<p>Rust has traditionally positioned itself as an “expression oriented
language”, that is, most things are expressions that evaluate to a value,
rather than statements. <code>loop</code> stuck out as strange in this way, as it was
previously a statement.</p>
<p>For now, this only applies to <code>loop</code>, and not things like <code>while</code> or <code>for</code>.
See the rationale for this decision in RFC issue <a href="https://github.com/rust-lang/rfcs/issues/1767">#1767</a>.</p>
<h1><a class="header" href="#asyncawait-for-easier-concurrency" id="asyncawait-for-easier-concurrency">async/await for easier concurrency</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /></p>
<p>The initial release of Rust 2018 won't ship with <code>async</code>/<code>await</code> support, but
we have reserved the keywords so that a future release will contain them.
We'll update this page when it's closer to shipping!</p>
<h1><a class="header" href="#trait-system" id="trait-system">Trait system</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to the trait system.
The most notable of these is <a href="rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html"><code>impl Trait</code></a>.</p>
<h1><a class="header" href="#impl-trait-for-returning-complex-types-with-ease" id="impl-trait-for-returning-complex-types-with-ease"><code>impl Trait</code> for returning complex types with ease</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p><code>impl Trait</code> is the new way to specify unnamed but concrete types that
implement a specific trait. There are two places you can put it: argument
position, and return position.</p>
<pre><code class="language-rust ignore">trait Trait {}

// argument position
fn foo(arg: impl Trait) {
}

// return position
fn foo() -&gt; impl Trait {
}
</code></pre>
<h2><a class="header" href="#argument-position" id="argument-position">Argument Position</a></h2>
<p>In argument position, this feature is quite simple. These two forms are
almost the same:</p>
<pre><code class="language-rust ignore">trait Trait {}

fn foo&lt;T: Trait&gt;(arg: T) {
}

fn foo(arg: impl Trait) {
}
</code></pre>
<p>That is, it's a slightly shorter syntax for a generic type parameter. It
means, &quot;<code>arg</code> is an argument that takes any type that implements the <code>Trait</code>
trait.&quot;</p>
<p>However, there's also an important technical difference between <code>T: Trait</code>
and <code>impl Trait</code> here. When you write the former, you can specify the type of
<code>T</code> at the call site with turbo-fish syntax as with <code>foo::&lt;usize&gt;(1)</code>. In the
case of <code>impl Trait</code>, if it is used anywhere in the function definition, then
you can't use turbo-fish at all. Therefore, you should be mindful that
changing both from and to <code>impl Trait</code> can constitute a breaking change for
the users of your code.</p>
<h2><a class="header" href="#return-position" id="return-position">Return Position</a></h2>
<p>In return position, this feature is more interesting. It means &quot;I am
returning some type that implements the <code>Trait</code> trait, but I'm not going to
tell you exactly what the type is.&quot; Before <code>impl Trait</code>, you could do this
with trait objects:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

impl Trait for i32 {}

fn returns_a_trait_object() -&gt; Box&lt;dyn Trait&gt; {
    Box::new(5)
}
<span class="boring">}
</span></code></pre></pre>
<p>However, this has some overhead: the <code>Box&lt;T&gt;</code> means that there's a heap
allocation here, and this will use dynamic dispatch. See the <code>dyn Trait</code>
section for an explanation of this syntax. But we only ever return one
possible thing here, the <code>Box&lt;i32&gt;</code>. This means that we're paying for dynamic
dispatch, even though we don't use it!</p>
<p>With <code>impl Trait</code>, the code above could be written like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

impl Trait for i32 {}

fn returns_a_trait_object() -&gt; impl Trait {
    5
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, we have no <code>Box&lt;T&gt;</code>, no trait object, and no dynamic dispatch. But we
still can obscure the <code>i32</code> return type.</p>
<p>With <code>i32</code>, this isn't super useful. But there's one major place in Rust
where this is much more useful: closures.</p>
<h3><a class="header" href="#impl-trait-and-closures" id="impl-trait-and-closures"><code>impl Trait</code> and closures</a></h3>
<blockquote>
<p>If you need to catch up on closures, check out <a href="https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html">their chapter in the
book</a>.</p>
</blockquote>
<p>In Rust, closures have a unique, un-writable type. They do implement the <code>Fn</code>
family of traits, however. This means that previously, the only way to return
a closure from a function was to use a trait object:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<p>You couldn't write the type of the closure, only use the <code>Fn</code> trait. That means
that the trait object is necessary. However, with <code>impl Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>We can now return closures by value, just like any other type!</p>
<h2><a class="header" href="#more-details-2" id="more-details-2">More details</a></h2>
<p>The above is all you need to know to get going with <code>impl Trait</code>, but for
some more nitty-gritty details: type parameters and <code>impl Trait</code> work
slightly differently when they're in argument position versus return
position. Consider this function:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Trait&gt;(x: T) {
</code></pre>
<p>When you call it, you set the type, <code>T</code>. &quot;you&quot; being the caller here. This
signature says &quot;I accept any type that implements <code>Trait</code>.&quot; (&quot;any type&quot; ==
universal in the jargon)</p>
<p>This version:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Trait&gt;() -&gt; T {
</code></pre>
<p>is similar, but also different. You, the caller, provide the type you want,
<code>T</code>, and then the function returns it. You can see this in Rust today with
things like parse or collect:</p>
<pre><code class="language-rust ignore">let x: i32 = &quot;5&quot;.parse()?;
let x: u64 = &quot;5&quot;.parse()?;
</code></pre>
<p>Here, <code>.parse</code> has this signature:</p>
<pre><code class="language-rust ignore">pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt; where
    F: FromStr,
</code></pre>
<p>Same general idea, though with a result type and <code>FromStr</code> has an associated
type... anyway, you can see how <code>F</code> is in the return position here. So you
have the ability to choose.</p>
<p>With <code>impl Trait</code>, you're saying &quot;hey, some type exists that implements this
trait, but I'm not gonna tell you what it is.&quot; So now, the caller can't
choose, and the function itself gets to choose. If we tried to define parse
with <code>Result&lt;impl F,...</code> as the return type, it wouldn't work.</p>
<h3><a class="header" href="#using-impl-trait-in-more-places" id="using-impl-trait-in-more-places">Using <code>impl Trait</code> in more places</a></h3>
<p>As previously mentioned, as a start, you will only be able to use <code>impl Trait</code>
as the argument or return type of a free or inherent function. However,
<code>impl Trait</code> can't be used inside implementations of traits, nor can it be
used as the type of a let binding or inside a type alias. Some of these
restrictions will eventually be lifted. For more information, see the
<a href="https://github.com/rust-lang/rust/issues/34511">tracking issue on <code>impl Trait</code></a>.</p>
<h1><a class="header" href="#dyn-trait-for-trait-objects" id="dyn-trait-for-trait-objects"><code>dyn Trait</code> for trait objects</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg" alt="Minimum Rust version: 1.27" /></p>
<p>The <code>dyn Trait</code> feature is the new syntax for using trait objects. In short:</p>
<ul>
<li><code>Box&lt;Trait&gt;</code> becomes <code>Box&lt;dyn Trait&gt;</code></li>
<li><code>&amp;Trait</code> and <code>&amp;mut Trait</code> become <code>&amp;dyn Trait</code> and <code>&amp;mut dyn Trait</code></li>
</ul>
<p>And so on. In code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

impl Trait for i32 {}

// old
fn function1() -&gt; Box&lt;Trait&gt; {
<span class="boring">unimplemented!()
</span>}

// new
fn function2() -&gt; Box&lt;dyn Trait&gt; {
<span class="boring">unimplemented!()
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>That's it!</p>
<h2><a class="header" href="#more-details-3" id="more-details-3">More details</a></h2>
<p>Using just the trait name for trait objects turned out to be a bad decision.
The current syntax is often ambiguous and confusing, even to veterans,
and favors a feature that is not more frequently used than its alternatives,
is sometimes slower, and often cannot be used at all when its alternatives can.</p>
<p>Furthermore, with <code>impl Trait</code> arriving, &quot;<code>impl Trait</code> vs <code>dyn Trait</code>&quot; is much
more symmetric, and therefore a bit nicer, than &quot;<code>impl Trait</code> vs <code>Trait</code>&quot;.
<code>impl Trait</code> is explained <a href="rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html">here</a>.</p>
<p>In the new edition, you should therefore prefer <code>dyn Trait</code> to just <code>Trait</code>
where you need a trait object.</p>
<h1><a class="header" href="#more-container-types-support-trait-objects" id="more-container-types-support-trait-objects">More container types support trait objects</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.2-brightgreen.svg" alt="Minimum Rust version: 1.2" /></p>
<p>In Rust 1.0, only certain, special types could be used to create <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait
objects</a>.</p>
<p>With Rust 1.2, that restriction was lifted, and more types became able to do this. For example,
<code>Rc&lt;T&gt;</code>, one of Rust's reference-counted types:</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

trait Foo {}

impl Foo for i32 {

}

fn main() {
    let obj: Rc&lt;dyn Foo&gt; = Rc::new(5);
}
</code></pre></pre>
<p>This code would not work with Rust 1.0, but now works.</p>
<blockquote>
<p>If you haven't seen the <code>dyn</code> syntax before, see <a href="rust-2018/trait-system/dyn-trait-for-trait-objects.html">the section on
it</a>. For versions that do not support it, replace <code>Rc&lt;dyn Foo&gt;</code>
with <code>Rc&lt;Foo&gt;</code>.</p>
</blockquote>
<h1><a class="header" href="#associated-constants" id="associated-constants">Associated constants</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.20-brightgreen.svg" alt="Minimum Rust version: 1.20" /></p>
<p>You can define traits, structs, and enums that have “associated functions”:</p>
<pre><pre class="playground"><code class="language-rust">struct Struct;

impl Struct {
    fn foo() {
        println!(&quot;foo is an associated function of Struct&quot;);
    }
}

fn main() {
    Struct::foo();
}
</code></pre></pre>
<p>These are called “associated functions” because they are functions that are
associated with the type, that is, they’re attached to the type itself, and
not any particular instance.</p>
<p>Rust 1.20 adds the ability to define “associated constants” as well:</p>
<pre><pre class="playground"><code class="language-rust">struct Struct;

impl Struct {
    const ID: u32 = 0;
}

fn main() {
    println!(&quot;the ID of Struct is: {}&quot;, Struct::ID);
}
</code></pre></pre>
<p>That is, the constant <code>ID</code> is associated with <code>Struct</code>. Like functions,
associated constants work with traits and enums as well.</p>
<p>Traits have an extra ability with associated constants that gives them some
extra power. With a trait, you can use an associated constant in the same way
you’d use an associated type: by declaring it, but not giving it a value. The
implementor of the trait then declares its value upon implementation:</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    const ID: u32;
}

struct Struct;

impl Trait for Struct {
    const ID: u32 = 5;
}

fn main() {
    println!(&quot;{}&quot;, Struct::ID);
}
</code></pre></pre>
<p>Before this feature, if you wanted to make a trait that represented floating
point numbers, you’d have to write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Float {
    fn nan() -&gt; Self;
    fn infinity() -&gt; Self;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This is slightly unwieldy, but more importantly, because they’re functions,
they cannot be used in constant expressions, even though they only return a
constant. Because of this, a design for <code>Float</code> would also have to include
constants as well:</p>
<pre><code class="language-rust ignore">mod f32 {
    const NAN: f32 = 0.0f32 / 0.0f32;
    const INFINITY: f32 = 1.0f32 / 0.0f32;

    impl Float for f32 {
        fn nan() -&gt; Self {
            f32::NAN
        }
        fn infinity() -&gt; Self {
            f32::INFINITY
        }
    }
}
</code></pre>
<p>Associated constants let you do this in a much cleaner way. This trait
definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Float {
    const NAN: Self;
    const INFINITY: Self;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Leads to this implementation:</p>
<pre><code class="language-rust ignore">mod f32 {
    impl Float for f32 {
        const NAN: f32 = 0.0f32 / 0.0f32;
        const INFINITY: f32 = 1.0f32 / 0.0f32;
    }
}
</code></pre>
<p>much cleaner, and more versatile.</p>
<h1><a class="header" href="#no-more-anonymous-trait-parameters" id="no-more-anonymous-trait-parameters">No more anonymous trait parameters</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<p>In accordance with RFC <a href="https://github.com/rust-lang/rfcs/pull/1685">#1685</a>,
parameters in trait method declarations are no longer allowed to be anonymous.</p>
<p>For example, in the 2015 edition, this was allowed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, u8);
}
<span class="boring">}
</span></code></pre></pre>
<p>In the 2018 edition, all parameters must be given an argument name  (even if it's just
<code>_</code>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, baz: u8);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#slice-patterns" id="slice-patterns">Slice patterns</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Have you ever tried to pattern match on the contents and structure of a slice?
Rust 2018 will let you do just that.</p>
<p>For example, say we want to accept a list of names and respond to that with a
greeting. With slice patterns, we can do that easy as pie with:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    greet(&amp;[]);
    // output: Bummer, there's no one here :(
    greet(&amp;[&quot;Alan&quot;]);
    // output: Hey, there Alan! You seem to be alone.
    greet(&amp;[&quot;Joan&quot;, &quot;Hugh&quot;]);
    // output: Hello, Joan and Hugh. Nice to see you are exactly 2!
    greet(&amp;[&quot;John&quot;, &quot;Peter&quot;, &quot;Stewart&quot;]);
    // output: Hey everyone, we seem to be 3 here today.
}

fn greet(people: &amp;[&amp;str]) {
    match people {
        [] =&gt; println!(&quot;Bummer, there's no one here :(&quot;),
        [only_one] =&gt; println!(&quot;Hey, there {}! You seem to be alone.&quot;, only_one),
        [first, second] =&gt; println!(
            &quot;Hello, {} and {}. Nice to see you are exactly 2!&quot;,
            first, second
        ),
        _ =&gt; println!(&quot;Hey everyone, we seem to be {} here today.&quot;, people.len()),
    }
}
</code></pre></pre>
<p>Now, you don't have to check the length first.</p>
<p>We can also match on arrays like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [1, 2, 3];

assert_eq!(&quot;ends with 3&quot;, match arr {
    [_, _, 3] =&gt; &quot;ends with 3&quot;,
    [a, b, c] =&gt; &quot;ends with something else&quot;,
});
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#more-details-4" id="more-details-4">More details</a></h2>
<h3><a class="header" href="#exhaustive-patterns" id="exhaustive-patterns">Exhaustive patterns</a></h3>
<p>In the first example, note in particular the <code>_ =&gt; ...</code> pattern.
Since we are matching on a slice, it could be of any length, so we need a
<em>&quot;catch all pattern&quot;</em> to handle it. If we forgot the <code>_ =&gt; ...</code> or
<code>identifier =&gt; ...</code> pattern, we would instead get an error saying:</p>
<pre><code class="language-ignore">error[E0004]: non-exhaustive patterns: `&amp;[_, _, _]` not covered
</code></pre>
<p>If we added a case for a slice of size <code>3</code> we would instead get:</p>
<pre><code class="language-ignore">error[E0004]: non-exhaustive patterns: `&amp;[_, _, _, _]` not covered
</code></pre>
<p>and so on...</p>
<h3><a class="header" href="#arrays-and-exact-lengths" id="arrays-and-exact-lengths">Arrays and exact lengths</a></h3>
<p>In the second example above, since arrays in Rust are of known lengths,
we have to match on exactly three elements.
If we try to match on 2 or 4 elements,we get the errors:</p>
<pre><code class="language-ignore">error[E0527]: pattern requires 2 elements but array has 3
</code></pre>
<p>and</p>
<pre><code class="language-ignore">error[E0527]: pattern requires 4 elements but array has 3
</code></pre>
<h3><a class="header" href="#in-the-pipeline" id="in-the-pipeline">In the pipeline</a></h3>
<p>When it comes to slice patterns, more advanced forms are planned but
have not been stabilized yet. To learn more, follow <a href="https://github.com/rust-lang/rust/issues/23121">the tracking issue</a>.</p>
<h1><a class="header" href="#ownership-and-lifetimes" id="ownership-and-lifetimes">Ownership and lifetimes</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to ownership and lifetimes.
One of the most notable of these is <a href="rust-2018/ownership-and-lifetimes/default-match-bindings.html">default match binding modes</a>.</p>
<h1><a class="header" href="#non-lexical-lifetimes" id="non-lexical-lifetimes">Non-lexical lifetimes</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /> for 2018 edition</p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg" alt="Minimum Rust version: 1.36" /> for 2015 edition</p>
<p>The borrow checker has been enhanced to accept more code, via a mechanism
called &quot;non-lexical lifetimes.&quot; Consider this example:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut x = 5;

    let y = &amp;x;

    let z = &amp;mut x;
}
</code></pre>
<p>In older Rust, this is a compile-time error:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:5:18
  |
4 |     let y = &amp;x;
  |              - immutable borrow occurs here
5 |     let z = &amp;mut x;
  |                  ^ mutable borrow occurs here
6 | }
  | - immutable borrow ends here
</code></pre>
<p>This is because lifetimes follow &quot;lexical scope&quot;; that is, the borrow from <code>y</code> is
considered to be held until <code>y</code> goes out of scope at the end of <code>main</code>, even though
we never use <code>y</code> again. This code is fine, but the borrow checker could not handle it.</p>
<p>Today, this code will compile just fine.</p>
<h2><a class="header" href="#better-errors" id="better-errors">Better errors</a></h2>
<p>What if we did use <code>y</code>, like this?</p>
<pre><code class="language-rust ignore">fn main() {
    let mut x = 5;
    let y = &amp;x;
    let z = &amp;mut x;

    println!(&quot;y: {}&quot;, y);
}
</code></pre>
<p>Here's the error:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:5:18
  |
4 |     let y = &amp;x;
  |              - immutable borrow occurs here
5 |     let z = &amp;mut x;
  |                  ^ mutable borrow occurs here
...
8 | }
  | - immutable borrow ends here
</code></pre>
<p>With non-lexical lifetimes, the error changes slightly:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:5:13
  |
4 |     let y = &amp;x;
  |             -- immutable borrow occurs here
5 |     let z = &amp;mut x;
  |             ^^^^^^ mutable borrow occurs here
6 |
7 |     println!(&quot;y: {}&quot;, y);
  |                       - borrow later used here
</code></pre>
<p>Instead of pointing to where <code>y</code> goes out of scope, it shows you where
the conflicting borrow occurs. This makes these sorts of errors <em>far</em> easier to debug.</p>
<h1><a class="header" href="#default-match-bindings" id="default-match-bindings">Default match bindings</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Have you ever had a borrowed <code>Option&lt;T&gt;</code> and tried to match on it? You
probably wrote this:</p>
<pre><code class="language-rust ignore">let s: &amp;Option&lt;String&gt; = &amp;Some(&quot;hello&quot;.to_string());

match s {
    Some(s) =&gt; println!(&quot;s is: {}&quot;, s),
    _ =&gt; (),
};
</code></pre>
<p>In Rust 2015, this would fail to compile, and you would have to write the
following instead:</p>
<pre><code class="language-rust ignore">// Rust 2015

let s: &amp;Option&lt;String&gt; = &amp;Some(&quot;hello&quot;.to_string());

match s {
    &amp;Some(ref s) =&gt; println!(&quot;s is: {}&quot;, s),
    _ =&gt; (),
};
</code></pre>
<p>Rust 2018, by contrast, will infer the <code>&amp;</code>s and <code>ref</code>s, and your original
code will Just Work.</p>
<p>This affects not just <code>match</code>, but patterns everywhere, such as in <code>let</code>
statements, closure arguments, and <code>for</code> loops.</p>
<h2><a class="header" href="#more-details-5" id="more-details-5">More details</a></h2>
<p>The mental model of patterns has shifted a bit with this change, to bring it
into line with other aspects of the language. For example, when writing a
<code>for</code> loop, you can iterate over borrowed contents of a collection by
borrowing the collection itself:</p>
<pre><code class="language-rust ignore">let my_vec: Vec&lt;i32&gt; = vec![0, 1, 2];

for x in &amp;my_vec { ... }
</code></pre>
<p>The idea is that an <code>&amp;T</code> can be understood as a <em>borrowed view of <code>T</code></em>, and
so when you iterate, match, or otherwise destructure a <code>&amp;T</code> you get a
borrowed view of its internals as well.</p>
<p>More formally, patterns have a &quot;binding mode,&quot; which is either by value
(<code>x</code>), by reference (<code>ref x</code>), or by mutable reference (<code>ref mut x</code>). In Rust
2015, <code>match</code> always started in by-value mode, and required you to explicitly
write <code>ref</code> or <code>ref mut</code> in patterns to switch to a borrowing mode. In Rust
2018, the type of the value being matched informs the binding mode, so that
if you match against an <code>&amp;Option&lt;String&gt;</code> with a <code>Some</code> variant, you are put
into <code>ref</code> mode automatically, giving you a borrowed view of the internal
data. Similarly, <code>&amp;mut Option&lt;String&gt;</code> would give you a <code>ref mut</code> view.</p>
<h1><a class="header" href="#_-the-anonymous-lifetime" id="_-the-anonymous-lifetime"><code>'_</code>, the anonymous lifetime</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<p>Rust 2018 allows you to explicitly mark where a lifetime is elided, for types
where this elision might otherwise be unclear. To do this, you can use the
special lifetime <code>'_</code> much like you can explicitly mark that a type is inferred
with the syntax <code>let x: _ = ..;</code>.</p>
<p>Let's say, for whatever reason, that we have a simple wrapper around <code>&amp;'a str</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StrWrap&lt;'a&gt;(&amp;'a str);
<span class="boring">}
</span></code></pre></pre>
<p>In Rust 2015, you might have written:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt;
</span><span class="boring">struct StrWrap&lt;'a&gt;(&amp;'a str);
</span>// Rust 2015

fn make_wrapper(string: &amp;str) -&gt; StrWrap {
    StrWrap(string)
}

impl&lt;'a&gt; fmt::Debug for StrWrap&lt;'a&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        fmt.write_str(self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In Rust 2018, you can instead write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt;
</span><span class="boring">struct StrWrap&lt;'a&gt;(&amp;'a str);
</span>// Rust 2018

fn make_wrapper(string: &amp;str) -&gt; StrWrap&lt;'_&gt; {
    StrWrap(string)
}

impl fmt::Debug for StrWrap&lt;'_&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        fmt.write_str(self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#more-details-6" id="more-details-6">More details</a></h2>
<p>In the Rust 2015 snippet above, we've used <code>-&gt; StrWrap</code>. However, unless you take
a look at the definition of <code>StrWrap</code>, it is not clear that the returned value
is actually borrowing something. Therefore, starting with Rust 2018, it is
deprecated to leave off the lifetime parameters for non-reference-types (types
other than <code>&amp;</code> and <code>&amp;mut</code>). Instead, where you previously wrote <code>-&gt; StrWrap</code>,
you should now write <code>-&gt; StrWrap&lt;'_&gt;</code>, making clear that borrowing is occurring.</p>
<p>What exactly does <code>'_</code> mean? It depends on the context!
In output contexts, as in the return type of <code>make_wrapper</code>,
it refers to a single lifetime for  all &quot;output&quot; locations.
In input contexts, a fresh lifetime is generated for each &quot;input location&quot;.
More concretely, to understand input contexts, consider the following example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 2015

struct Foo&lt;'a, 'b: 'a&gt; {
    field: &amp;'a &amp;'b str,
}

impl&lt;'a, 'b: 'a&gt; Foo&lt;'a, 'b&gt; {
    // some methods...
}
<span class="boring">}
</span></code></pre></pre>
<p>We can rewrite this as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo&lt;'a, 'b: 'a&gt; {
</span><span class="boring">    field: &amp;'a &amp;'b str,
</span><span class="boring">}
</span>
// Rust 2018

impl Foo&lt;'_, '_&gt; {
    // some methods...
}
<span class="boring">}
</span></code></pre></pre>
<p>This is the same, because for each <code>'_</code>, a fresh lifetime is generated.
Finally, the relationship <code>'a: 'b</code> which the struct requires must be upheld.</p>
<p>For more details, see the <a href="https://github.com/rust-lang/rust/issues/44524">tracking issue on In-band lifetime bindings</a>.</p>
<h1><a class="header" href="#lifetime-elision-in-impl" id="lifetime-elision-in-impl">Lifetime elision in impl</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<p>When writing <code>impl</code> blocks, you can now elide lifetime annotations in some
situations.</p>
<p>Consider a trait like <code>MyIterator</code>:</p>
<pre><code class="language-rust ignore">trait MyIterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre>
<p>In Rust 2015, if we wanted to implement this iterator for mutable references
to <code>Iterators</code>, we'd need to write this:</p>
<pre><code class="language-rust ignore">impl&lt;'a, I: MyIterator&gt; MyIterator for &amp;'a mut I {
    type Item = I::Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        (*self).next()
    }
}
</code></pre>
<p>Note all of the <code>'a</code> annotations. In Rust 2018, we can write this:</p>
<pre><code class="language-rust ignore">impl&lt;I: MyIterator&gt; MyIterator for &amp;mut I {
    type Item = I::Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        (*self).next()
    }
}
</code></pre>
<p>Similarly, lifetime annotations can appear due to a struct that contains
references:</p>
<pre><code class="language-rust ignore">struct SetOnDrop&lt;'a, T&gt; {
    borrow: &amp;'a mut T,
    value: Option&lt;T&gt;,
}
</code></pre>
<p>In Rust 2015, to implement <code>Drop</code> on this struct, we'd write:</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; Drop for SetOnDrop&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        if let Some(x) = self.value.take() {
            *self.borrow = x;
        }
    }
}
</code></pre>
<p>But in Rust 2018, we can combine elision with <a href="rust-2018/ownership-and-lifetimes/the-anonymous-lifetime.html">the anonymous lifetime</a> and
write this instead.</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for SetOnDrop&lt;'_, T&gt; {
    fn drop(&amp;mut self) {
        if let Some(x) = self.value.take() {
            *self.borrow = x;
        }
    }
}
</code></pre>
<h1><a class="header" href="#t-a-inference-in-structs" id="t-a-inference-in-structs"><code>T: 'a</code> inference in structs</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<p>An annotation in the form of <code>T: 'a</code>, where <code>T</code> is either a type or another
lifetime, is called an <em>&quot;outlives&quot;</em> requirement. Note that <em>&quot;outlives&quot;</em> also
implies <code>'a: 'a</code>.</p>
<p>One way in which edition 2018 helps you out in maintaining flow when writing
programs is by removing the need to explicitly annotate these <code>T: 'a</code> outlives
requirements in <code>struct</code> definitions. Instead, the requirements will be
inferred from the fields present in the definitions.</p>
<p>Consider the following <code>struct</code> definitions in Rust 2015:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 2015

struct Ref&lt;'a, T: 'a&gt; {
    field: &amp;'a T
}

// or written with a `where` clause:

struct WhereRef&lt;'a, T&gt; where T: 'a {
    data: &amp;'a T
}

// with nested references:

struct RefRef&lt;'a, 'b: 'a, T: 'b&gt; {
    field: &amp;'a &amp;'b T,
}

// using an associated type:

struct ItemRef&lt;'a, T: Iterator&gt;
where
    T::Item: 'a
{
    field: &amp;'a T::Item
}
<span class="boring">}
</span></code></pre></pre>
<p>In Rust 2018, since the requirements are inferred, you can instead write:</p>
<pre><code class="language-rust ignore">// Rust 2018

struct Ref&lt;'a, T&gt; {
    field: &amp;'a T
}

struct WhereRef&lt;'a, T&gt; {
    data: &amp;'a T
}

struct RefRef&lt;'a, 'b, T&gt; {
    field: &amp;'a &amp;'b T,
}

struct ItemRef&lt;'a, T: Iterator&gt; {
    field: &amp;'a T::Item
}
</code></pre>
<p>If you prefer to be more explicit in some cases, that is still possible.</p>
<h2><a class="header" href="#more-details-7" id="more-details-7">More details</a></h2>
<p>For more details, see <a href="https://github.com/rust-lang/rust/issues/44493">the tracking issue</a>
and <a href="https://github.com/rust-lang/rfcs/pull/2093">the RFC</a>.</p>
<h1><a class="header" href="#simpler-lifetimes-in-static-and-const" id="simpler-lifetimes-in-static-and-const">Simpler lifetimes in <code>static</code> and <code>const</code></a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.17-brightgreen.svg" alt="Minimum Rust version: 1.17" /></p>
<p>In older Rust, you had to explicitly write the <code>'static</code> lifetime in any
<code>static</code> or <code>const</code> that needed a lifetime:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod foo {
</span>const NAME: &amp;'static str = &quot;Ferris&quot;;
<span class="boring">}
</span><span class="boring">mod bar {
</span>static NAME: &amp;'static str = &quot;Ferris&quot;;
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>But <code>'static</code> is the only possible lifetime there. So Rust now assumes the <code>'static</code> lifetime,
and you don't have to write it out:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod foo {
</span>const NAME: &amp;str = &quot;Ferris&quot;;
<span class="boring">}
</span><span class="boring">mod bar {
</span>static NAME: &amp;str = &quot;Ferris&quot;;
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>In some situations, this can remove a <em>lot</em> of boilerplate:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod foo {
</span>// old
const NAMES: &amp;'static [&amp;'static str; 2] = &amp;[&quot;Ferris&quot;, &quot;Bors&quot;];
<span class="boring">}
</span><span class="boring">mod bar {
</span>
// new
const NAMES: &amp;[&amp;str; 2] = &amp;[&quot;Ferris&quot;, &quot;Bors&quot;];
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#data-types" id="data-types">Data types</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to data types.
One of these are <a href="rust-2018/data-types/field-init-shorthand.html">field-init-shorthand</a>.</p>
<h1><a class="header" href="#field-init-shorthand" id="field-init-shorthand">Field init shorthand</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.17-brightgreen.svg" alt="Minimum Rust version: 1.17" /></p>
<p>In older Rust, when initializing a struct, you must always give the full set of <code>key: value</code> pairs
for its fields:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

let a = 5;
let b = 6;

let p = Point {
    x: a,
    y: b,
};
<span class="boring">}
</span></code></pre></pre>
<p>However, often these variables would have the same names as the fields. So you'd end up
with code that looks like this:</p>
<pre><code class="language-rust ignore">let p = Point {
    x: x,
    y: y,
};
</code></pre>
<p>Now, if the variable is of the same name, you don't have to write out both, just write out the key:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

let x = 5;
let y = 6;

// new
let p = Point {
    x,
    y,
};
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#-for-inclusive-ranges" id="-for-inclusive-ranges"><code>..=</code> for inclusive ranges</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Since well before Rust 1.0, you’ve been able to create exclusive ranges with
<code>..</code> like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 1..3 {
    println!(&quot;i: {}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will print <code>i: 1</code> and then <code>i: 2</code>. Today, you can now create an
inclusive range, like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 1..=3 {
    println!(&quot;i: {}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will print <code>i: 1</code> and then <code>i: 2</code> like before, but also <code>i: 3</code>; the
three is included in the range. Inclusive ranges are especially useful if you
want to iterate over every possible value in a range. For example, this is a
surprising Rust program:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn takes_u8(x: u8) {
    // ...
}

fn main() {
    for i in 0..256 {
        println!(&quot;i: {}&quot;, i);
        takes_u8(i);
    }
}
</code></pre></pre>
<p>What does this program do? The answer: it fails to compile. The error we get
when compiling has a hint:</p>
<pre><code class="language-text">error: literal out of range for u8
 --&gt; src/main.rs:6:17
  |
6 |     for i in 0..256 {
  |                 ^^^
  |
  = note: #[deny(overflowing_literals)] on by default
</code></pre>
<p>That’s right, since <code>i</code> is a <code>u8</code>, this overflows, and the compiler produces
an error.</p>
<p>We can do this with inclusive ranges, however:</p>
<pre><pre class="playground"><code class="language-rust">fn takes_u8(x: u8) {
    // ...
}

fn main() {
    for i in 0..=255 {
        println!(&quot;i: {}&quot;, i);
        takes_u8(i);
    }
}
</code></pre></pre>
<p>This will produce those 256 lines of output you might have been expecting.</p>
<h1><a class="header" href="#128-bit-integers" id="128-bit-integers">128 bit integers</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>A very simple feature: Rust now has 128 bit integers!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i128 = 0;
let y: u128 = 0;
<span class="boring">}
</span></code></pre></pre>
<p>These are twice the size of <code>u64</code>, and so can hold more values. More specifically,</p>
<ul>
<li><code>u128</code>: <code>0</code> - <code>340,282,366,920,938,463,463,374,607,431,768,211,455</code></li>
<li><code>i128</code>: <code>−170,141,183,460,469,231,731,687,303,715,884,105,728</code> - <code>170,141,183,460,469,231,731,687,303,715,884,105,727</code></li>
</ul>
<p>Whew!</p>
<h1><a class="header" href="#operator-equals-are-now-implementable" id="operator-equals-are-now-implementable">&quot;Operator-equals&quot; are now implementable</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.8-brightgreen.svg" alt="Minimum Rust version: 1.8" /></p>
<p>The various “operator equals” operators, such as <code>+=</code> and <code>-=</code>, are
implementable via various traits. For example, to implement <code>+=</code> on
a type of your own:</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::AddAssign;

#[derive(Debug)]
struct Count { 
    value: i32,
}

impl AddAssign for Count {
    fn add_assign(&amp;mut self, other: Count) {
        self.value += other.value;
    }
}

fn main() {
    let mut c1 = Count { value: 1 };
    let c2 = Count { value: 5 };

    c1 += c2;

    println!(&quot;{:?}&quot;, c1);
}
</code></pre></pre>
<p>This will print <code>Count { value: 6 }</code>.</p>
<h1><a class="header" href="#union-for-an-unsafe-form-of-enum" id="union-for-an-unsafe-form-of-enum"><code>union</code> for an unsafe form of <code>enum</code></a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.19-brightgreen.svg" alt="Minimum Rust version: 1.19" /></p>
<p>Rust now supports <code>unions</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Unions are kind of like enums, but they are “untagged”. Enums have a “tag”
that stores which variant is the correct one at runtime; unions don't have
this tag.</p>
<p>Since we can interpret the data held in the union using the wrong variant and
Rust can’t check this for us, that means reading a union’s field is unsafe:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion {
</span><span class="boring">    f1: u32,
</span><span class="boring">    f2: f32,
</span><span class="boring">}
</span>let mut u = MyUnion { f1: 1 };

u.f1 = 5;

let value = unsafe { u.f1 };
<span class="boring">}
</span></code></pre></pre>
<p>Pattern matching works too:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion {
</span><span class="boring">    f1: u32,
</span><span class="boring">    f2: f32,
</span><span class="boring">}
</span>fn f(u: MyUnion) {
    unsafe {
        match u {
            MyUnion { f1: 10 } =&gt; { println!(&quot;ten&quot;); }
            MyUnion { f2 } =&gt; { println!(&quot;{}&quot;, f2); }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>When are unions useful? One major use-case is interoperability with C. C APIs
can (and depending on the area, often do) expose unions, and so this makes
writing API wrappers for those libraries significantly easier. Additionally,
unions also simplify Rust implementations of space-efficient or
cache-efficient structures relying on value representation, such as
machine-word-sized unions using the least-significant bits of aligned
pointers to distinguish cases.</p>
<p>There’s still more improvements to come. For now, unions can only include
<code>Copy</code> types and may not implement <code>Drop</code>. We expect to lift these
restrictions in the future.</p>
<h1><a class="header" href="#choosing-alignment-with-the-repr-attribute" id="choosing-alignment-with-the-repr-attribute">Choosing alignment with the repr attribute</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p>From <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Wikipedia</a>:</p>
<blockquote>
<p>The CPU in modern computer hardware performs reads and writes to memory
most efficiently when the data is naturally aligned, which generally means
that the data address is a multiple of the data size. Data alignment refers
to aligning elements according to their natural alignment. To ensure natural
alignment, it may be necessary to insert some padding between structure
elements or after the last element of a structure.</p>
</blockquote>
<p>The <code>#[repr]</code> attribute has a new parameter, <code>align</code>, that sets the alignment of your struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Number(i32);

assert_eq!(std::mem::align_of::&lt;Number&gt;(), 4);
assert_eq!(std::mem::size_of::&lt;Number&gt;(), 4);

#[repr(align(16))]
struct Align16(i32);

assert_eq!(std::mem::align_of::&lt;Align16&gt;(), 16);
assert_eq!(std::mem::size_of::&lt;Align16&gt;(), 16);
<span class="boring">}
</span></code></pre></pre>
<p>If you’re working with low-level stuff, control of these kinds of things can
be very important!</p>
<p>The alignment of a type is normally not worried about as the compiler will
&quot;do the right thing&quot; of picking an appropriate alignment for general use
cases. There are situations, however, where a nonstandard alignment may be
desired when operating with foreign systems. For example these sorts of
situations tend to necessitate or be much easier with a custom alignment:</p>
<ul>
<li>Hardware can often have obscure requirements such as &quot;this structure is
aligned to 32 bytes&quot; when it in fact is only composed of 4-byte values. While
this can typically be manually calculated and managed, it's often also useful
to express this as a property of a type to get the compiler to do a little
extra work instead.</li>
<li>C compilers like <code>gcc</code> and <code>clang</code> offer the ability to specify a custom
alignment for structures, and Rust can much more easily interoperate with
these types if Rust can also mirror the request for a custom alignment (e.g.
passing a structure to C correctly is much easier).</li>
<li>Custom alignment can often be used for various tricks here and there and is
often convenient as &quot;let's play around with an implementation&quot; tool. For
example this can be used to statically allocate page tables in a kernel or
create an at-least cache-line-sized structure easily for concurrent
programming.</li>
</ul>
<p>The purpose of this feature is to provide a lightweight annotation to alter
the compiler-inferred alignment of a structure to enable these situations
much more easily.</p>
<h1><a class="header" href="#simd-for-faster-computing" id="simd-for-faster-computing">SIMD for faster computing</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg" alt="Minimum Rust version: 1.27" /></p>
<p>The basics of <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> are now available!
SIMD stands for “single instruction, multiple data.” Consider a function like
this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn foo(a: &amp;[u8], b: &amp;[u8], c: &amp;mut [u8]) {
    for ((a, b), c) in a.iter().zip(b).zip(c) {
        *c = *a + *b;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, we’re taking two slices, and adding the numbers together, placing the
result in a third slice. The simplest possible way to do this would be to do
exactly what the code does, and loop through each set of elements, add them
together, and store it in the result. However, compilers can often do better.
LLVM will usually “autovectorize” code like this, which is a fancy term for
“use SIMD.” Imagine that <code>a</code> and <code>b</code> were both 16 elements long. Each element
is a <code>u8</code>, and so that means that each slice would be 128 bits of data. Using
SIMD, we could put both <code>a</code> and <code>b</code> into 128 bit registers, add them together
in a <em>single</em> instruction, and then copy the resulting 128 bits into <code>c</code>.
That’d be much faster!</p>
<p>While stable Rust has always been able to take advantage of
autovectorization, sometimes, the compiler just isn’t smart enough to realize
that we can do something like this. Additionally, not every CPU has these
features, and so LLVM may not use them so your program can be used on a wide
variety of hardware. The <code>std::arch</code> module allows us to use these kinds of
instructions directly, which means we don’t need to rely on a smart compiler.
Additionally, it includes some features that allow us to choose a particular
implementation based on various criteria. For example:</p>
<pre><code class="language-rust ignore">#[cfg(all(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;),
      target_feature = &quot;avx2&quot;))]
fn foo() {
    #[cfg(target_arch = &quot;x86&quot;)]
    use std::arch::x86::_mm256_add_epi64;
    #[cfg(target_arch = &quot;x86_64&quot;)]
    use std::arch::x86_64::_mm256_add_epi64;

    unsafe {
        _mm256_add_epi64(...);
    }
}
</code></pre>
<p>Here, we use cfg flags to choose the correct version based on the machine
we’re targeting; on x86 we use that version, and on x86_64 we use its
version. We can also choose at runtime:</p>
<pre><code class="language-rust ignore">fn foo() {
    #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
    {
        if is_x86_feature_detected!(&quot;avx2&quot;) {
            return unsafe { foo_avx2() };
        }
    }

    foo_fallback();
}
</code></pre>
<p>Here, we have two versions of the function: one which uses AVX2, a specific
kind of SIMD feature that lets you do 256-bit operations. The
<code>is_x86_feature_detected!</code> macro will generate code that detects if your CPU
supports AVX2, and if so, calls the foo_avx2 function. If not, then we fall
back to a non-AVX implementation, foo_fallback. This means that our code will
run super fast on CPUs that support AVX2, but still work on ones that don’t,
albeit slower.</p>
<p>If all of this seems a bit low-level and fiddly, well, it is! <code>std::arch</code> is
specifically primitives for building these kinds of things. We hope to
eventually stabilize a <code>std::simd</code> module with higher-level stuff in the
future. But landing the basics now lets the ecosystem experiment with higher
level libraries starting today. For example, check out the
<a href="https://github.com/AdamNiederer/faster">faster</a> crate. Here’s a code snippet
with no SIMD:</p>
<pre><code class="language-rust ignore">let lots_of_3s = (&amp;[-123.456f32; 128][..]).iter()
    .map(|v| {
        9.0 * v.abs().sqrt().sqrt().recip().ceil().sqrt() - 4.0 - 2.0
    })
    .collect::&lt;Vec&lt;f32&gt;&gt;();
</code></pre>
<p>To use SIMD with this code via faster, you’d change it to this:</p>
<pre><code class="language-rust ignore">let lots_of_3s = (&amp;[-123.456f32; 128][..]).simd_iter()
    .simd_map(f32s(0.0), |v| {
        f32s(9.0) * v.abs().sqrt().rsqrt().ceil().sqrt() - f32s(4.0) - f32s(2.0)
    })
    .scalar_collect();
</code></pre>
<p>It looks almost the same: <code>simd_iter</code> instead of <code>iter</code>, <code>simd_map</code> instead of <code>map</code>,
<code>f32s(2.0)</code> instead of <code>2.0</code>. But you get a SIMD-ified version generated for you.</p>
<p>Beyond that, you may never write any of this yourself, but as always, the
libraries you depend on may. For example, the regex crate contains these SIMD
speedups without you needing to do anything at all!</p>
<h1><a class="header" href="#macros-1" id="macros-1">Macros</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to the macro system.
A notable addition here is the introduction of <a href="rust-2018/macros/custom-derive.html">custom derive macros</a>.</p>
<h1><a class="header" href="#custom-derive" id="custom-derive">Custom Derive</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.15-brightgreen.svg" alt="Minimum Rust version: 1.15" /></p>
<p>In Rust, you’ve always been able to automatically implement some traits
through the derive attribute:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Pet {
    name: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Debug</code> trait is then implemented for <code>Pet</code>, with vastly less boilerplate. For example, without <code>derive</code>, you'd have
to write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

struct Pet {
    name: String,
}

impl fmt::Debug for Pet {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            Pet { name } =&gt; {
                let mut debug_trait_builder = f.debug_struct(&quot;Pet&quot;);

                let _ = debug_trait_builder.field(&quot;name&quot;, name);

                debug_trait_builder.finish()
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Whew!</p>
<p>However, this only worked for traits provided as part of the standard
library; it was not customizable. But now, you can tell Rust what to do when
someone wants to derive your trait. This is used heavily in popular crates
like <a href="https://serde.rs/">serde</a> and <a href="http://diesel.rs/">Diesel</a>.</p>
<p>For more, including learning how to build your own custom derive, see <a href="https://doc.rust-lang.org/book/ch19-06-macros.html#how-to-write-a-custom-derive-macro">The
Rust Programming
Language</a>.</p>
<h1><a class="header" href="#macro-changes" id="macro-changes">Macro changes</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<h2><a class="header" href="#macro_rules-style-macros" id="macro_rules-style-macros"><code>macro_rules!</code> style macros</a></h2>
<p>In Rust 2018, you can import specific macros from external crates via <code>use</code>
statements, rather than the old <code>#[macro_use]</code> attribute.</p>
<p>For example, consider a <code>bar</code> crate that implements a <code>baz!</code> macro. In
<code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! baz {
    () =&gt; ()
}
<span class="boring">}
</span></code></pre></pre>
<p>In your crate, you would have written</p>
<pre><code class="language-rust ignore">// Rust 2015

#[macro_use]
extern crate bar;

fn main() {
    baz!();
}
</code></pre>
<p>Now, you write:</p>
<pre><code class="language-rust ignore">// Rust 2018

use bar::baz;

fn main() {
    baz!();
}
</code></pre>
<p>This moves <code>macro_rules</code> macros to be a bit closer to other kinds of items.</p>
<p>Note that you'll still need <code>#[macro_use]</code> to use macros you've defined
in your own crate; this feature only works for importing macros from
external crates.</p>
<h2><a class="header" href="#procedural-macros" id="procedural-macros">Procedural macros</a></h2>
<p>When using procedural macros to derive traits, you will have to name the macro
that provides the custom derive. This generally matches the name of the trait,
but check with the documentation of the crate providing the derives to be sure.</p>
<p>For example, with Serde you would have written</p>
<pre><code class="language-rust ignore">// Rust 2015
extern crate serde;
#[macro_use] extern crate serde_derive;

#[derive(Serialize, Deserialize)]
struct Bar;
</code></pre>
<p>Now, you write instead:</p>
<pre><code class="language-rust ignore">// Rust 2018
use serde_derive::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Bar;
</code></pre>
<h2><a class="header" href="#more-details-8" id="more-details-8">More details</a></h2>
<p>This only works for macros defined in external crates.
For macros defined locally, <code>#[macro_use] mod foo;</code> is still required, as it was in Rust 2015.</p>
<h3><a class="header" href="#local-helper-macros" id="local-helper-macros">Local helper macros</a></h3>
<p>Sometimes it is helpful or necessary to have helper macros inside your module. This can make
supporting both versions of rust more complicated.</p>
<p>For example, let's make a simplified (and slightly contrived) version of the <code>log</code> crate in 2015
edition style:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

/// How important/severe the log message is.
#[derive(Copy, Clone)]
pub enum LogLevel {
    Warn,
    Error
}

impl fmt::Display for LogLevel {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            LogLevel::Warn =&gt; write!(f, &quot;warning&quot;),
            LogLevel::Error =&gt; write!(f, &quot;error&quot;),
        }
    }
}

// A helper macro to log the message.
#[doc(hidden)]
#[macro_export]
macro_rules! __impl_log {
    ($level:expr, $msg:expr) =&gt; {{
        println!(&quot;{}: {}&quot;, $level, $msg)
    }}
}

/// Warn level log message
#[macro_export]
macro_rules! warn {
    ($($args:tt)*) =&gt; {
        __impl_log!($crate::LogLevel::Warn, format_args!($($args)*))
    }
}

/// Error level log message
#[macro_export]
macro_rules! error {
    ($($args:tt)*) =&gt; {
        __impl_log!($crate::LogLevel::Error, format_args!($($args)*))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>__impl_log!</code> macro is private to our module, but needs to be exported as it is called by other
macros, and in 2015 edition all used macros must be exported.</p>
<p>Now, in 2018 this example will not compile:</p>
<pre><code class="language-rust ignore">use log::error;

fn main() {
    error!(&quot;error message&quot;);
}
</code></pre>
<p>will give an error message about not finding the <code>__impl_log!</code> macro. This is because unlike in 
the 2015 edition, macros are namespaced and we must import them. We could do</p>
<pre><code class="language-rust ignore">use log::{__impl_log, error};
</code></pre>
<p>which would make our code compile, but <code>__impl_log</code> is meant to be an implementation detail!</p>
<h4><a class="header" href="#macros-with-crate-prefix" id="macros-with-crate-prefix">Macros with <code>$crate::</code> prefix.</a></h4>
<p>The cleanest way to handle this situation is to use the <code>$crate::</code> prefix for macros, the same as
you would for any other path. Versions of the compiler &gt;= 1.30 will handle this in both editions:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! warn {
    ($($args:tt)*) =&gt; {
        $crate::__impl_log!($crate::LogLevel::Warn, format_args!($($args)*))
    }
}

// ...
<span class="boring">}
</span></code></pre></pre>
<p>However, this will not work for older versions of the compiler that don't understand the
<code>$crate::</code> prefix for macros.</p>
<h4><a class="header" href="#macros-using-local_inner_macros" id="macros-using-local_inner_macros">Macros using <code>local_inner_macros</code></a></h4>
<p>We also have the <code>local_inner_macros</code> modifier that we can add to our <code>#[macro_export]</code> attribute.
This has the advantage of working with older rustc versions (older versions just ignore the extra
modifier). The downside is that it's a bit messier:</p>
<pre><code class="language-rust ignore">#[macro_export(local_inner_macros)]
macro_rules! warn {
    ($($args:tt)*) =&gt; {
        __impl_log!($crate::LogLevel::Warn, format_args!($($args)*))
    }
}
</code></pre>
<p>So the code knows to look for any macros used locally. But wait - this won't compile, because we
use the <code>format_args!</code> macro that isn't in our local crate (hence the convoluted example). The
solution is to add a level of indirection: we create a macro that wraps <code>format_args</code>, but is local 
to our crate. That way everything works in both editions (sadly we have to pollute the global
namespace a bit, but that's ok).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I've used the pattern `_&lt;my crate  name&gt;__&lt;macro name&gt;` to name this macro, hopefully avoiding
// name clashes.
#[doc(hidden)]
#[macro_export]
macro_rules! _log__format_args {
    ($($inner:tt)*) =&gt; {
        format_args! { $($inner)* }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we're using the most general macro pattern possible, a list of token trees. We just pass
whatever tokens we get to the inner macro, and rely on it to report errors.</p>
<p>So the full 2015/2018 working example would be:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

/// How important/severe the log message is.
#[derive(Debug, Copy, Clone)]
pub enum LogLevel {
    Warn,
    Error
}

impl fmt::Display for LogLevel {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            LogLevel::Warn =&gt; write!(f, &quot;warning&quot;),
            LogLevel::Error =&gt; write!(f, &quot;error&quot;),
        }
    }
}

// A helper macro to log the message.
#[doc(hidden)]
#[macro_export]
macro_rules! __impl_log {
    ($level:expr, $msg:expr) =&gt; {{
        println!(&quot;{}: {}&quot;, $level, $msg)
    }}
}

/// Warn level log message
#[macro_export(local_inner_macros)]
macro_rules! warn {
    ($($args:tt)*) =&gt; {
        __impl_log!($crate::LogLevel::Warn, _log__format_args!($($args)*))
    }
}

/// Error level log message
#[macro_export(local_inner_macros)]
macro_rules! error {
    ($($args:tt)*) =&gt; {
        __impl_log!($crate::LogLevel::Error, _log__format_args!($($args)*))
    }
}

#[doc(hidden)]
#[macro_export]
macro_rules! _log__format_args {
    ($($inner:tt)*) =&gt; {
        format_args! { $($inner)* }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Once everyone is using a rustc version &gt;= 1.30, we can all just use the <code>$crate::</code> method (2015
crates are guaranteed to carry on compiling fine with later versions of the compiler). We need to
wait for package managers and larger organisations to update their compilers before this happens,
so in the mean time we can use the <code>local_inner_macros</code> method to support everybody. :)</p>
<h1><a class="header" href="#at-most-one-repetition" id="at-most-one-repetition">At most one repetition</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /> for 2018 edition</p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.37-brightgreen.svg" alt="Minimum Rust version: 1.37" /> for 2015 edition</p>
<p>In Rust 2018, we have made a couple of changes to the macros-by-example syntax.</p>
<ol>
<li>We have added a new Kleene operator <code>?</code> which means &quot;at most one&quot;
repetition. This operator does not accept a separator token.</li>
<li>We have disallowed using <code>?</code> as a separator to remove ambiguity with <code>?</code>.</li>
</ol>
<p>For example, consider the following Rust 2015 code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
    ($a:ident, $b:expr) =&gt; {
        println!(&quot;{}&quot;, $a);
        println!(&quot;{}&quot;, $b);
    };
    ($a:ident) =&gt; {
        println!(&quot;{}&quot;, $a);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Macro <code>foo</code> can be called with 1 or 2 arguments; the second one is optional,
but you need a whole other matcher to represent this possibility. This is
annoying if your matchers are long. In Rust 2018, one can simply write the
following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
    ($a:ident $(, $b:expr)?) =&gt; {
        println!(&quot;{}&quot;, $a);

        $(
            println!(&quot;{}&quot;, $b);
         )?
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#the-compiler" id="the-compiler">The compiler</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to the compiler.
A notable addition here is our new and <a href="rust-2018/the-compiler/improved-error-messages.html">improved error messages</a>.</p>
<h1><a class="header" href="#improved-error-messages" id="improved-error-messages">Improved error messages</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.12-brightgreen.svg" alt="Minimum Rust version: 1.12" /></p>
<p>We're always working on error improvements, and there are little improvements
in almost every Rust version, but in Rust 1.12, a significant overhaul of the
error message system was created.</p>
<p>For example, here's some code that produces an error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main() {
    let mut x = 5;
    let y = &amp;x;
    x += 1;
    println!(&quot;{} {}&quot;, x, y);
}
</code></pre></pre>
<p>Here's the error in Rust 1.11:</p>
<pre><code class="language-text">foo.rs:4:5: 4:11 error: cannot assign to `x` because it is borrowed [E0506]
foo.rs:4     x += 1;
             ^~~~~~
foo.rs:3:14: 3:15 note: borrow of `x` occurs here
foo.rs:3     let y = &amp;x;
                      ^
foo.rs:4:5: 4:11 help: run `rustc --explain E0506` to see a detailed explanation
error: aborting due to previous error
</code></pre>
<p>Here's the error in Rust 1.28:</p>
<pre><code class="language-text">error[E0506]: cannot assign to `x` because it is borrowed
 --&gt; foo.rs:4:5
  |
3 |     let y = &amp;x;
  |              - borrow of `x` occurs here
4 |     x += 1;
  |     ^^^^^^ assignment to borrowed `x` occurs here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0506`.
</code></pre>
<p>This error isn't terribly different, but shows off how the format has changed. It shows
off your code in context, rather than just showing the text of the lines themselves.</p>
<h1><a class="header" href="#incremental-compilation" id="incremental-compilation">Incremental Compilation</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.24-brightgreen.svg" alt="Minimum Rust version: 1.24" /></p>
<p>Back in September of 2016, we <a href="https://blog.rust-lang.org/2016/09/08/incremental.html">blogged about Incremental
Compilation</a>. While
that post goes into the details, the idea is basically this: when you’re
working on a project, you often compile it, then change something small, then
compile again. Historically, the compiler has compiled your entire project,
no matter how little you’ve changed the code. The idea with incremental
compilation is that you only need to compile the code you’ve actually
changed, which means that that second build is faster.</p>
<p>This is now turned on by default. This means that your builds should be
faster! Don’t forget about <code>cargo check</code> when trying to get the lowest possible
build times.</p>
<p>This is still not the end story for compiler performance generally, nor
incremental compilation specifically. We have a lot more work planned in the
future.</p>
<p>One small note about this change: it makes builds faster, but makes the final
binary a bit slower. For this reason, it's not turned on in release builds.</p>
<h1><a class="header" href="#an-attribute-for-deprecation" id="an-attribute-for-deprecation">An attribute for deprecation</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.9-brightgreen.svg" alt="Minimum Rust version: 1.9" /></p>
<p>If you're writing a library, and you'd like to deprecate something, you can
use the <code>deprecated</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(
    since = &quot;0.2.1&quot;,
    note = &quot;Please use the bar function instead&quot;
)]
pub fn foo() {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This will give your users a warning if they use the deprecated functionality:</p>
<pre><code class="language-text">   Compiling playground v0.0.1 (file:///playground)
warning: use of deprecated item 'foo': Please use the bar function instead
  --&gt; src/main.rs:10:5
   |
10 |     foo();
   |     ^^^
   |
   = note: #[warn(deprecated)] on by default

</code></pre>
<p>Both <code>since</code> and <code>note</code> are optional.</p>
<p><code>since</code> can be in the future; you can put whatever you'd like, and what's put in
there isn't checked.</p>
<h1><a class="header" href="#rustup-for-managing-rust-versions" id="rustup-for-managing-rust-versions">Rustup for managing Rust versions</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-various-brightgreen.svg" alt="Minimum Rust version: various" /> (this tool has its own versioning scheme and works with all Rust versions)</p>
<p>The <a href="https://rustup.rs/">Rustup</a> tool has become <em>the</em> recommended way to
install Rust, and is advertised on our website. Its powers go further than
that though, allowing you to manage various versions, components, and
platforms.</p>
<h2><a class="header" href="#for-installing-rust" id="for-installing-rust">For installing Rust</a></h2>
<p>To install Rust through Rustup, you can go to
<a href="https://www.rust-lang.org/install.html">https://www.rust-lang.org/install.html</a>, which will let you know how to do
so on your platform. This will install both <code>rustup</code> itself and the <code>stable</code>
version of <code>rustc</code> and <code>cargo</code>.</p>
<p>To install a specific Rust version, you can use <code>rustup toolchain install</code>:</p>
<pre><code class="language-console">$ rustup toolchain install 1.30.0
</code></pre>
<p>This works for a specific nightly, as well:</p>
<pre><code class="language-console">$ rustup toolchain install nightly-2018-08-01
</code></pre>
<p>As well as any of our release channels:</p>
<pre><code class="language-console">$ rustup toolchain install stable
$ rustup toolchain install beta
$ rustup toolchain install nightly
</code></pre>
<h2><a class="header" href="#for-updating-your-installation" id="for-updating-your-installation">For updating your installation</a></h2>
<p>To update all of the various channels you may have installed:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>This will look at everything you've installed, and if there are new releases,
will update anything that has one.</p>
<h2><a class="header" href="#managing-versions" id="managing-versions">Managing versions</a></h2>
<p>To set the default toolchain to something other than <code>stable</code>:</p>
<pre><code class="language-console">$ rustup default nightly
</code></pre>
<p>To uninstall a specific Rust version, you can use <code>rustup toolchain uninstall</code>:</p>
<pre><code class="language-console">$ rustup toolchain uninstall 1.30.0
</code></pre>
<p>To use a toolchain other than the default, use <code>rustup run</code>:</p>
<pre><code class="language-console">$ rustup run nightly cargo build
</code></pre>
<p>There's also an alias for this that's a little shorter:</p>
<pre><code class="language-console">$ cargo +nightly build
</code></pre>
<p>If you'd like to have a different default per-directory, that's easy too!
If you run this inside of a project:</p>
<pre><code class="language-console">$ rustup override set nightly
</code></pre>
<p>Or, if you'd like to target a different version of Rust:</p>
<pre><code class="language-console">$ rustup override set 1.30.0
</code></pre>
<p>Then when you're in that directory, any invocations of <code>rustc</code> or <code>cargo</code>
will use that toolchain. To share this with others, you can create a
<code>rust-toolchain</code> file with the contents of a toolchain, and check it into
source control. Now, when someone clones your project, they'll get the
right version without needing to <code>override set</code> themselves.</p>
<h2><a class="header" href="#installing-other-targets" id="installing-other-targets">Installing other targets</a></h2>
<p>Rust supports cross-compiling to other targets, and Rustup can help you
manage them. For example, to use MUSL:</p>
<pre><code class="language-console">$ rustup target add x86_64-unknown-linux-musl
</code></pre>
<p>And then you can</p>
<pre><code class="language-console">$ cargo build --target=x86_64-unknown-linux-musl
</code></pre>
<p>To see the full list of targets you can install:</p>
<pre><code class="language-console">$ rustup target list
</code></pre>
<h2><a class="header" href="#installing-components" id="installing-components">Installing components</a></h2>
<p>Components are used to install certain kinds of tools. While <code>cargo-install</code>
has you covered for most tools, some tools need deep integration into the
compiler. Rustup knows exactly what version of the compiler you're using, and
so it's got just the information that these tools need.</p>
<p>Components are per-toolchain, so if you want them to be available to more
than one toolchain, you'll need to install them multiple times. In the
following examples, add a <code>--toolchain</code> flag, set to the toolchain you
want to install for, <code>nightly</code> for example. Without this flag, it will
install the component for the default toolchain.</p>
<p>To see the full list of components you can install:</p>
<pre><code class="language-console">$ rustup component list
</code></pre>
<p>Next, let's talk about some popular components and when you might want to
install them.</p>
<h3><a class="header" href="#rust-docs-for-local-documentation" id="rust-docs-for-local-documentation"><code>rust-docs</code>, for local documentation</a></h3>
<p>This first component is installed by default when you install a toolchain. It
contains a copy of Rust's documentation, so that you can read it offline.</p>
<p>This component cannot be removed for now; if that's of interest, please
comment on <a href="https://github.com/rust-lang/rustup.rs/issues/998">this
issue</a>.</p>
<h3><a class="header" href="#rust-src-for-a-copy-of-rusts-source-code" id="rust-src-for-a-copy-of-rusts-source-code"><code>rust-src</code> for a copy of Rust's source code</a></h3>
<p>The <code>rust-src</code> component can give you a local copy of Rust's source code. Why
might you need this? Well, autocompletion tools like Racer use this
information to know more about the functions you're trying to call.</p>
<pre><code class="language-console">$ rustup component add rust-src
</code></pre>
<h3><a class="header" href="#rustfmt-for-automatic-code-formatting" id="rustfmt-for-automatic-code-formatting"><code>rustfmt</code> for automatic code formatting</a></h3>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.24-brightgreen.svg" alt="Minimum Rust version: 1.24" /></p>
<p>If you'd like to have your code automatically formatted, you can
install this component:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>This will install two tools, <code>rustfmt</code> and <code>cargo-fmt</code>, that will reformat your
code for you! For example:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>will reformat your entire Cargo project.</p>
<h3><a class="header" href="#rls-for-ide-integration" id="rls-for-ide-integration"><code>rls</code> for IDE integration</a></h3>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>Many IDE features are built off of the <a href="http://langserver.org/"><code>langserver</code>
protocol</a>. To gain support for Rust with these IDEs,
you'll need to install the Rust language sever, aka the &quot;RLS&quot;:</p>
<pre><code class="language-console">$ rustup component add rls
</code></pre>
<p>For more information about integrating this into your IDE, see the <a href="https://github.com/rust-lang/rls">RLS
documentation</a>.</p>
<h3><a class="header" href="#clippy-for-more-lints" id="clippy-for-more-lints"><code>clippy</code> for more lints</a></h3>
<p>For even more lints to help you write Rust code, you can install <code>clippy</code>:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>This will install <code>cargo-clippy</code> for you:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>For more, check out <a href="https://github.com/rust-lang/rust-clippy">clippy's
documentation</a>.</p>
<h3><a class="header" href="#the-preview-components" id="the-preview-components">The &quot;preview&quot; components</a></h3>
<p>There are several components in a &quot;preview&quot; stage. These components currently
have <code>-preview</code> in their name, and this indicates that they're not quite 100%
ready for general consumption yet. Please try them out and give us feedback,
but know that they do not follow Rust's stability guarantees, and are still
actively changing, possibly in backwards-incompatible ways.</p>
<h4><a class="header" href="#llvm-tools-preview-for-using-extra-llvm-tools" id="llvm-tools-preview-for-using-extra-llvm-tools"><code>llvm-tools-preview</code> for using extra LLVM tools</a></h4>
<p>If you'd like to use the <code>lld</code> linker, or other tools like <code>llvm-objdump</code> or
<code>llvm-objcopy</code>, you can install this component:</p>
<pre><code class="language-console">$ rustup component add llvm-tools-preview
</code></pre>
<p>This is the newest component, and so doesn't have good documentation at the
moment.</p>
<h1><a class="header" href="#cargo-and-cratesio" id="cargo-and-cratesio">Cargo and crates.io</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to <code>cargo</code> and <a href="https://crates.io">crates.io</a>.
A notable addition here is the new <a href="rust-2018/cargo-and-crates-io/cargo-check-for-faster-checking.html"><code>cargo check</code></a> command.</p>
<h1><a class="header" href="#cargo-check-for-faster-checking" id="cargo-check-for-faster-checking"><code>cargo check</code> for faster checking</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.16-brightgreen.svg" alt="Minimum Rust version: 1.16" /></p>
<p><code>cargo check</code> is a new subcommand that should speed up the development
workflow in many cases.</p>
<p>What does it do? Let's take a step back and talk about how <code>rustc</code> compiles
your code. Compilation has many &quot;passes&quot;, that is, there are many distinct
steps that the compiler takes on the road from your source code to producing
the final binary. However, you can think of this process in two big steps:
first, <code>rustc</code> does all of its safety checks, makes sure your syntax is
correct, all that stuff. Second, once it's satisfied that everything is in
order, it produces the actual binary code that you end up executing.</p>
<p>It turns out that that second step takes a lot of time. And most of the time,
it's not necessary. That is, when you're working on some Rust code, many
developers will get into a workflow like this:</p>
<ol>
<li>Write some code.</li>
<li>Run <code>cargo build</code> to make sure it compiles.</li>
<li>Repeat 1-2 as needed.</li>
<li>Run <code>cargo test</code> to make sure your tests pass.</li>
<li>Try the binary yourself</li>
<li>GOTO 1.</li>
</ol>
<p>In step two, you never actually run your code. You're looking for feedback
from the compiler, not to actually run the binary. <code>cargo check</code> supports
exactly this use-case: it runs all of the compiler's checks, but doesn't
produce the final binary. To use it:</p>
<pre><code class="language-console">$ cargo check
</code></pre>
<p>where you may normally <code>cargo build</code>. The workflow now looks like:</p>
<ol>
<li>Write some code.</li>
<li>Run <code>cargo check</code> to make sure it compiles.</li>
<li>Repeat 1-2 as needed.</li>
<li>Run <code>cargo test</code> to make sure your tests pass.</li>
<li>Run <code>cargo build</code> to build a binary and try it yourself</li>
<li>GOTO 1.</li>
</ol>
<p>So how much speedup do you actually get? Like most performance related
questions, the answer is &quot;it depends.&quot; Here are some very un-scientific
benchmarks at the time of writing.</p>
<table><thead><tr><th>use case</th><th>build performance</th><th>check performance</th><th>speedup</th></tr></thead><tbody>
<tr><td>initial compile</td><td>11s</td><td>5.6s</td><td>1.96x</td></tr>
<tr><td>second compile (no changes)</td><td>3s</td><td>1.9s</td><td>1.57x</td></tr>
<tr><td>third compile with small change</td><td>5.8s</td><td>3s</td><td>1.93x</td></tr>
</tbody></table>
<h1><a class="header" href="#cargo-install-for-easy-installation-of-tools" id="cargo-install-for-easy-installation-of-tools"><code>cargo install</code> for easy installation of tools</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.5-brightgreen.svg" alt="Minimum Rust version: 1.5" /></p>
<p>Cargo has grown a new <code>install</code> command. This is intended to be used for installing
new subcommands for Cargo, or tools for Rust developers. This doesn't replace the need
to build real, native packages for end-users on the platforms you support.</p>
<p>For example, this guide is created with <a href="https://crates.io/crates/mdbook"><code>mdbook</code></a>. You
can install it on your system with</p>
<pre><code class="language-console">$ cargo install mdbook
</code></pre>
<p>And then use it with</p>
<pre><code class="language-console">$ mdbook --help
</code></pre>
<h2><a class="header" href="#cargo-extensions" id="cargo-extensions">Cargo Extensions</a></h2>
<p>As an example of extending Cargo, you can use the <a href="https://crates.io/crates/cargo-update"><code>cargo-update</code></a>
package. To install it:</p>
<pre><code class="language-console">$ cargo install cargo-update
</code></pre>
<p>This will allow you to use <code>cargo install-update -a</code> command, which checks everything you've <code>cargo install</code>'d and
updates it to the latest version.</p>
<h1><a class="header" href="#cargo-new-defaults-to-a-binary-project" id="cargo-new-defaults-to-a-binary-project"><code>cargo new</code> defaults to a binary project</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p><code>cargo new</code> will now default to generating a binary, rather than a library.
We try to keep Cargo’s CLI quite stable, but this change is important, and is
unlikely to cause breakage.</p>
<p>For some background, <code>cargo new</code> accepts two flags: <code>--lib</code>, for creating
libraries, and <code>--bin</code>, for creating binaries, or executables. If you don’t
pass one of these flags, it used to default to <code>--lib</code>. At the time, we made
this decision because each binary (often) depends on many libraries, and so
we thought the library case would be more common. However, this is incorrect;
each library is depended upon by many binaries. Furthermore, when getting
started, what you often want is a program you can run and play around with.
It’s not just new Rustaceans though; even very long-time community members
have said that they find this default surprising. As such, we’ve changed it,
and it now defaults to <code>--bin</code>.</p>
<h1><a class="header" href="#cargo-rustc-for-passing-arbitrary-flags-to-rustc" id="cargo-rustc-for-passing-arbitrary-flags-to-rustc"><code>cargo rustc</code> for passing arbitrary flags to rustc</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.1-brightgreen.svg" alt="Minimum Rust version: 1.1" /></p>
<p><code>cargo rustc</code> is a new subcommand for Cargo that allows you to pass arbitrary
<code>rustc</code> flags through Cargo.</p>
<p>For example, Cargo does not have a way to pass unstable flags built-in. But
if we'd like to use <code>print-type-sizes</code> to see what layout information our
types have, we can run this:</p>
<pre><code class="language-console">$ cargo rustc -- -Z print-type-sizes
</code></pre>
<p>And we'll get a bunch of output describing the size of our types.</p>
<h2><a class="header" href="#note" id="note">Note</a></h2>
<p><code>cargo rustc</code> only passes these flags to invocations of your crate, and not to any <code>rustc</code>
invocations used to build dependencies. If you'd like to do that, see <code>$RUSTFLAGS</code>.</p>
<h1><a class="header" href="#cargo-workspaces-for-multi-package-projects" id="cargo-workspaces-for-multi-package-projects">Cargo workspaces for multi-package projects</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.12-brightgreen.svg" alt="Minimum Rust version: 1.12" /></p>
<p>Cargo used to have two levels of organization:</p>
<ul>
<li>A <em>package</em> contains one or more crates</li>
<li>A crate has one or more modules</li>
</ul>
<p>Cargo now has an additional level:</p>
<ul>
<li>A <em>workspace</em> contains one or more packages</li>
</ul>
<p>This can be useful for larger projects. For example, <a href="https://github.com/rust-lang/futures-rs">the <code>futures</code> package</a>
is a <em>workspace</em> that contains many related packages:</p>
<ul>
<li>futures</li>
<li>futures-util</li>
<li>futures-io</li>
<li>futures-channel</li>
</ul>
<p>and more.</p>
<p>Workspaces allow these packages to be developed individually, but they share
a single set of dependencies, and therefore have a single target directory
and a single <code>Cargo.lock</code>.</p>
<p>For more details about workspaces, please see <a href="https://doc.rust-lang.org/stable/cargo/reference/manifest.html#the-workspace-section">the Cargo documentation</a>.</p>
<h1><a class="header" href="#multi-file-examples" id="multi-file-examples">Multi-file examples</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.22-brightgreen.svg" alt="Minimum Rust version: 1.22" /></p>
<p>Cargo has an <code>examples</code> feature for showing people how to use your package.
By putting individual files inside of the top-level <code>examples</code> directory, you
can create multiple examples.</p>
<p>But what if your example is too big for a single file? Cargo supports adding
sub-directories inside of <code>examples</code>, and looks for a <code>main.rs</code> inside of
them to build the example. It looks like this:</p>
<pre><code class="language-text">my-package
 └──src
     └── lib.rs // code here
 └──examples 
     └── simple-example.rs // a single-file example
     └── complex-example
        └── helper.rs
        └── main.rs // a more complex example that also uses `helper` as a submodule
</code></pre>
<h1><a class="header" href="#replacing-dependencies-with-patch" id="replacing-dependencies-with-patch">Replacing dependencies with patch</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>The <code>[patch]</code> section of your <code>Cargo.toml</code> can be used when you want to
override certain parts of your dependency graph.</p>
<blockquote>
<p>Cargo has a <code>[replace]</code> feature that is similar; while we don't intend to deprecate
or remove <code>[replace]</code>, you should prefer <code>[patch]</code> in all circumstances.</p>
</blockquote>
<p>So what’s it look like? Let’s say we have a Cargo.toml that looks like this:</p>
<pre><code class="language-toml">[dependencies]
foo = &quot;1.2.3&quot;
</code></pre>
<p>In addition, our <code>foo</code> package depends on a <code>bar</code> crate, and we find a bug in <code>bar</code>.
To test this out, we’d download the source code for <code>bar</code>, and then update our
<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
foo = &quot;1.2.3&quot;

[patch.crates-io]
bar = { path = '/path/to/bar' }
</code></pre>
<p>Now, when you <code>cargo build</code>, it will use the local version of <code>bar</code>, rather
than the one from crates.io that <code>foo</code> depends on. You can then try out your
changes, and fix that bug!</p>
<p>For more details, see <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-patch-section">the documentation for
<code>patch</code></a>.</p>
<h1><a class="header" href="#cargo-can-use-a-local-registry-replacement" id="cargo-can-use-a-local-registry-replacement">Cargo can use a local registry replacement</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.12-brightgreen.svg" alt="Minimum Rust version: 1.12" /></p>
<p>Cargo finds its packages in a &quot;source&quot;. The default source is <a href="https://crates.io">crates.io</a>. However, you
can choose a different source in your <code>.cargo/config</code>:</p>
<pre><code class="language-toml">[source.crates-io]
replace-with = 'my-awesome-registry'

[source.my-awesome-registry]
registry = 'https://github.com/my-awesome/registry-index'
</code></pre>
<p>This configuration means that instead of using crates.io, Cargo will query
the <code>my-awesome-registry</code> source instead (configured to a different index
here). This alternate source <em>must be the exact same</em> as the crates.io index.
Cargo assumes that replacement sources are exact 1:1 mirrors in this respect,
and the following support is designed around that assumption.</p>
<p>When generating a lock file for crate using a replacement registry, the
original registry will be encoded into the lock file. For example in the
configuration above, all lock files will still mention crates.io as the
registry that packages originated from. This semantically represents how
crates.io is the source of truth for all crates, and this is upheld because
all replacements have a 1:1 correspondance.</p>
<p>Overall, this means that no matter what replacement source you're working
with, you can ship your lock file to anyone else and you'll all still have
verifiably reproducible builds!</p>
<p>This has enabled tools like
<a href="https://github.com/alexcrichton/cargo-vendor"><code>cargo-vendor</code></a> and
<a href="https://github.com/alexcrichton/cargo-local-registry"><code>cargo-local-registry</code></a>,
which are often useful for &quot;offline builds.&quot; They prepare the list of all
Rust dependencies ahead of time, which lets you ship them to a build machine
with ease.</p>
<h1><a class="header" href="#cratesio-disallows-wildcard-dependencies" id="cratesio-disallows-wildcard-dependencies">Crates.io disallows wildcard dependencies</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.6-brightgreen.svg" alt="Minimum Rust version: 1.6" /></p>
<p>Crates.io will not allow you to upload a package with a wildcard dependency.
In other words, these:</p>
<pre><code class="language-toml">[dependencies]
regex = &quot;*&quot;
</code></pre>
<p>A wildcard dependency means that you work with any possible version of your
dependency. This is highly unlikely to be true, and would cause unnecessary
breakage in the ecosystem.</p>
<p>Instead, depend on a version range. For example, <code>^</code> is the default, so
you could use</p>
<pre><code class="language-toml">[dependencies]
regex = &quot;1.0.0&quot;
</code></pre>
<p>instead. <code>&gt;</code>, <code>&lt;=</code>, and all of the other, non-<code>*</code> ranges work as well.</p>
<h1><a class="header" href="#documentation" id="documentation">Documentation</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to documentation.
A notable addition here is the <a href="rust-2018/documentation/new-editions-of-the-book.html">second edition of &quot;the book&quot;</a>.</p>
<h1><a class="header" href="#new-editions-of-the-the-book" id="new-editions-of-the-the-book">New editions of the &quot;the book&quot;</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /> for the final version of the second edition</p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /> for the 2018 edition</p>
<p>We've distributed a copy of &quot;The Rust Programming Language,&quot; affectionately
nicknamed &quot;the book&quot;, with every version of Rust since Rust 1.0.</p>
<p>However, because it was written before Rust 1.0, it started showing its age.
Many parts of the book are vague, because it was written before the true
details were nailed down for the 1.0 release. It didn't do a fantastic job of
teaching lifetimes.</p>
<p>Starting with Rust 1.18, we shipped drafts of a second edition of the book.
The final version was shipped with Rust 1.26. The second edition is a complete
re-write from the ground up, using the last two years of knowledge we’ve
gained from teaching people Rust.</p>
<p>You can purchase <a href="https://nostarch.com/Rust">a printed version of the second edition from No Starch
Press</a>. Now that the print version has shipped, the
second edition is frozen.</p>
<p>As of 1.31, the book has been completely updated for the 2018 Edition release.
It's still pretty close to the second edition, but contains information about
newer features since the book's content was frozen. Additionally, instead of
publishing separate editions of the book, only the latest version of the book
is published online. You’ll find brand-new explanations for a lot of Rust’s
core concepts, new projects to build, and all kinds of other good stuff.
Please <a href="https://doc.rust-lang.org/book/index.html">check it out</a> and let us
know what you think!</p>
<h1><a class="header" href="#the-rust-bookshelf" id="the-rust-bookshelf">The Rust Bookshelf</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-various-brightgreen.svg" alt="Minimum Rust version: various" />, each book is different.</p>
<p>As Rust's documentation has grown, we've gained far more than just &quot;The book&quot;
and the reference. We now have a collection of various long-form docs,
nicknamed &quot;the Rust Bookshelf.&quot; Different resources are added at various
times, and we're adding new ones as more get written.</p>
<h2><a class="header" href="#the-cargo-book" id="the-cargo-book">The Cargo book</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>Historically, Cargo’s docs were hosted on <a href="http://doc.crates.io">http://doc.crates.io</a>, which
doesn’t follow the release train model, even though Cargo itself does. This
led to situations where a feature would land in Cargo nightly, the docs would
be updated, and then for up to twelve weeks, users would think that it should
work, but it wouldn’t yet. <a href="https://doc.rust-lang.org/cargo">https://doc.rust-lang.org/cargo</a> is the new home
of Cargo’s docs, and <a href="http://doc.crates.io">http://doc.crates.io</a> now redirects there.</p>
<h2><a class="header" href="#the-rustdoc-book" id="the-rustdoc-book">The <code>rustdoc</code> book</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>Rustdoc, our documentation tool, now has a guide at <a href="https://doc.rust-lang.org/rustdoc">https://doc.rust-lang.org/rustdoc</a>.</p>
<h2><a class="header" href="#rust-by-example" id="rust-by-example">Rust By Example</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p>Rust by Example used to live at <a href="https://rustbyexample.com">https://rustbyexample.com</a>, but now is part of the Bookshelf!
It can be found at <a href="https://doc.rust-lang.org/rust-by-example/">https://doc.rust-lang.org/rust-by-example/</a>. RBE lets you learn Rust through
short code examples and exercises, as opposed to the lengthy prose of The Book.</p>
<h1><a class="header" href="#the-rustonomicon" id="the-rustonomicon">The Rustonomicon</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.3-brightgreen.svg" alt="Minimum Rust version: 1.3" /></p>
<p>We now have a draft book, <a href="https://doc.rust-lang.org/stable/nomicon/">The Rustonomicon: the Dark Arts of Advanced and
Unsafe Rust Programming</a>.</p>
<p>From the title, I'm sure you can guess: this book discusses some advanced
topics, including <code>unsafe</code>. It's a must-read for anyone who's working at the
lowest levels with Rust.</p>
<h1><a class="header" href="#stdos-has-documentation-for-all-platforms" id="stdos-has-documentation-for-all-platforms"><code>std::os</code> has documentation for all platforms</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>The <code>std::os</code> module contains operating system specific functionality. You’ll
now see more than just linux, the platform we build the documentation on.</p>
<p>We’ve long regretted that the hosted version of the documentation has been
Linux-specific; this is a first step towards rectifying that. This is
specific to the standard library and not for general use; we hope to improve
this further in the future.</p>
<h1><a class="header" href="#rustdoc" id="rustdoc"><code>rustdoc</code></a></h1>
<p>In this chapter of the guide, we discuss a few improvements to <code>rustdoc</code>.
A notable addition to it was <a href="rust-2018/rustdoc/documentation-tests-can-now-compile-fail.html">that documentation tests can now compile-fail</a>.</p>
<h1><a class="header" href="#documentation-tests-can-now-compile-fail" id="documentation-tests-can-now-compile-fail">Documentation tests can now compile-fail</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.22-brightgreen.svg" alt="Minimum Rust version: 1.22" /></p>
<p>You can now create <code>compile-fail</code> tests in Rustdoc, like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```compile_fail
/// let x = 5;
/// x += 2; // shouldn't compile!
/// ```
<span class="boring">fn foo() {}
</span><span class="boring">}
</span></code></pre></pre>
<p>Please note that these kinds of tests can be more fragile than others, as
additions to Rust may cause code to compile when it previously would not.
Consider the first release with <code>?</code>, for example: code using <code>?</code> would fail
to compile on Rust 1.21, but compile successfully on Rust 1.22, causing your
test suite to start failing.</p>
<h1><a class="header" href="#rustdoc-uses-commonmark" id="rustdoc-uses-commonmark">Rustdoc uses CommonMark</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /> for support by default</p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.23-red.svg" alt="Minimum Rust version: 1.23" /> for support via a flag</p>
<p>Rustdoc lets you write documentation comments in Markdown. At Rust 1.0, we
were using the <code>hoedown</code> markdown implementation, written in C. Markdown is
more of a family of implementations of an idea, and so <code>hoedown</code> had its own
dialect, like many parsers. The <a href="https://commonmark.org/">CommonMark project</a>
has attempted to define a more strict version of Markdown, and so now, Rustdoc
uses it by default.</p>
<p>As of Rust 1.23, we still defaulted to <code>hoedown</code>, but you could enable
Commonmark via a flag, <code>--enable-commonmark</code>. Today, we only support
CommonMark.</p>
<h1><a class="header" href="#platform-and-target-support" id="platform-and-target-support">Platform and target support</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to platform and target support.
A notable addition to it was <a href="rust-2018/platform-and-target-support/libcore-for-low-level-rust.html">that the <code>libcore</code> library now works on stable Rust</a>.</p>
<h1><a class="header" href="#libcore-for-low-level-rust" id="libcore-for-low-level-rust">libcore for low-level Rust</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.6-brightgreen.svg" alt="Minimum Rust version: 1.6" /></p>
<p>Rust’s standard library is two-tiered: there’s a small core library,
<code>libcore</code>, and the full standard library, <code>libstd</code>, that builds on top of it.
<code>libcore</code> is completely platform agnostic, and requires only a handful of
external symbols to be defined. Rust’s <code>libstd</code> builds on top of <code>libcore</code>,
adding support for things like memory allocation and I/O. Applications using
Rust in the embedded space, as well as those writing operating systems, often
eschew <code>libstd</code>, using only <code>libcore</code>.</p>
<p>As an additional note, while building <em>libraries</em> with <code>libcore</code> is supported
today, building full applications is not yet stable.</p>
<p>To use <code>libcore</code>, add this flag to your crate root:</p>
<pre><code class="language-rust ignore">#![no_std]
</code></pre>
<p>This will remove the standard library, and bring the <code>core</code> crate into your
namespace for use:</p>
<pre><code class="language-rust ignore">#![no_std]

use core::cell::Cell;
</code></pre>
<p>You can find <code>libcore</code>'s documentation <a href="https://doc.rust-lang.org/core/">here</a>.</p>
<h1><a class="header" href="#webassembly-support" id="webassembly-support">WebAssembly support</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.14-brightgreen.svg" alt="Minimum Rust version: 1.14" /> for <code>emscripten</code></p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /> for <code>wasm32-unknown-unknown</code></p>
<p>Rust has gained support for <a href="https://webassembly.org/">WebAssembly</a>, meaning
that you can run Rust code in your browser, client-side.</p>
<p>In Rust 1.14, we gained support through
<a href="http://kripken.github.io/emscripten-site/index.html">emscripten</a>. With it
installed, you can write Rust code and have it produce
<a href="http://asmjs.org/">asm.js</a> (the precusor to wasm) and/or WebAssembly.</p>
<p>Here's an example of using this support:</p>
<pre><code class="language-console">$ rustup target add wasm32-unknown-emscripten
$ echo 'fn main() { println!(&quot;Hello, Emscripten!&quot;); }' &gt; hello.rs
$ rustc --target=wasm32-unknown-emscripten hello.rs
$ node hello.js
</code></pre>
<p>However, in the meantime, Rust has also grown its own support, independent
from Emscripten. This is known as &quot;the unknown target&quot;, because instead of
<code>wasm32-unknown-emscripten</code>, it's <code>wasm32-unknown-unknown</code>. This will be
the preferred target to use once it's ready, but for now, it's really
only well-supported in nightly.</p>
<h1><a class="header" href="#global-allocators" id="global-allocators">Global allocators</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.28-brightgreen.svg" alt="Minimum Rust version: 1.28" /></p>
<p>Allocators are the way that programs in Rust obtain memory from the system at
runtime. Previously, Rust did not allow changing the way memory is obtained,
which prevented some use cases. On some platforms, this meant using jemalloc,
on others, the system allocator, but there was no way for users to control
this key component. With 1.28.0, the <code>#[global_allocator]</code> attribute is now
stable, which allows Rust programs to set their allocator to the system
allocator, as well as define new allocators by implementing the <code>GlobalAlloc</code>
trait.</p>
<p>The default allocator for Rust programs on some platforms is jemalloc. The
standard library now provides a handle to the system allocator, which can be
used to switch to the system allocator when desired, by declaring a static
and marking it with the <code>#[global_allocator]</code> attribute.</p>
<pre><pre class="playground"><code class="language-rust">use std::alloc::System;

#[global_allocator]
static GLOBAL: System = System;

fn main() {
    let mut v = Vec::new();
    // This will allocate memory using the system allocator.
    v.push(1);
}
</code></pre></pre>
<p>However, sometimes you want to define a custom allocator for a given
application domain. This is also relatively easy to do by implementing the
<code>GlobalAlloc</code> trait. You can read more about how to do this in <a href="https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html">the
documentation</a>.</p>
<h1><a class="header" href="#msvc-toolchain-support" id="msvc-toolchain-support">MSVC toolchain support</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.2-brightgreen.svg" alt="Minimum Rust version: 1.2" /></p>
<p>At the release of Rust 1.0, we only supported the GNU toolchain on Windows. With the
release of Rust 1.2, we introduced initial support for the MSVC toolchain. After that,
as support matured, we eventually made it the default choice for Windows users.</p>
<p>The difference between the two matters for interacting with C. If you're using a library
built with one toolchain or another, you need to match that with the appropriate Rust
toolchain. If you're not sure, go with MSVC; it's the default for good reason.</p>
<p>To use this feature, simply use Rust on Windows, and the installer will default to it.
If you'd prefer to switch to the GNU toolchain, you can install it with Rustup:</p>
<pre><code class="language-console">$ rustup toolchain install stable-x86_64-pc-windows-gnu
</code></pre>
<h1><a class="header" href="#musl-support-for-fully-static-binaries" id="musl-support-for-fully-static-binaries">MUSL support for fully static binaries</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.1-brightgreen.svg" alt="Minimum Rust version: 1.1" /></p>
<p>By default, Rust will statically link all Rust code. However, if you use the
standard library, it will dynamically link to the system's <code>libc</code>
implementation.</p>
<p>If you'd like a 100% static binary, the <a href="https://www.musl-libc.org/"><code>MUSL libc</code></a> can be used on Linux.</p>
<h2><a class="header" href="#installing-musl-support" id="installing-musl-support">Installing MUSL support</a></h2>
<p>To add support for MUSL, you need to choose the correct target. <a href="https://forge.rust-lang.org/release/platform-support.html">The forge
has a full list of
targets</a> supported,
with a number of ones using <code>musl</code>.</p>
<p>If you're not sure what you want, it's probably <code>x86_64-unknown-linux-musl</code>,
for 64-bit Linux. We'll be using this target in this guide, but the
instructions remain the same for other targets, just change the name wherever
we mention the target.</p>
<p>To get support for this target, you use <code>rustup</code>:</p>
<pre><code class="language-console">$ rustup target add x86_64-unknown-linux-musl
</code></pre>
<p>This will install support for the default toolchain; to install for other toolchains,
add the <code>--toolchain</code> flag. For example:</p>
<pre><code class="language-console">$ rustup target add x86_64-unknown-linux-musl --toolchain=nightly
</code></pre>
<h2><a class="header" href="#building-with-musl" id="building-with-musl">Building with MUSL</a></h2>
<p>To use this new target, pass the <code>--target</code> flag to Cargo:</p>
<pre><code class="language-console">$ cargo build --target x86_64-unknown-linux-musl
</code></pre>
<p>The binary produced will now be built with MUSL!</p>
<h1><a class="header" href="#cdylib-crates-for-c-interoperability" id="cdylib-crates-for-c-interoperability">cdylib crates for C interoperability</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.10-brightgreen.svg" alt="Minimum Rust version: 1.10" /> for <code>rustc</code></p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.11-brightgreen.svg" alt="Minimum Rust version: 1.11" /> for <code>cargo</code></p>
<p>If you're producing a library that you intend to be used from C (or another
language through a C FFI), there's no need for Rust to include Rust-specific
stuff in the final object code. For libraries like that, you'll want to use
the <code>cdylib</code> crate type in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>This will produce a smaller binary, with no Rust-specific information inside
of it.</p>
<!--
# The Next Edition
-->
<h1><a class="header" href="#次のエディション" id="次のエディション">次のエディション</a></h1>
<!--
We have not decided if and when the next edition will ship; there is talk of
a 2021 edition to keep up the three-year schedule, but that has not been
formally decided.
-->
<p>次のエディションを作るのかどうか、そして作るのであればいつ公開するのかはまだ決めていません。
3年ごとというスケジュールを守るために2021エディションの話がされていますが、公式には決められていません。</p>
<!--
Until we do, this section keeps track of changes that landed after Rust 2018.
-->
<p>次のエディションが決定事項になるまで、このセクションではRust 2018以降に導入された変更点を記録していきます。</p>
<!--
# Next-Specific Changes
 -->
<h1><a class="header" href="#次のエディションに特有の変更" id="次のエディションに特有の変更">次のエディションに特有の変更</a></h1>
<!--
There have been no specific changes accepted for the next edition yet.
 -->
<p>次のエディションだけに適用される変更で、承諾されたものはまだありません。</p>
<!--
# The dbg! macro
-->
<h1><a class="header" href="#dbg-マクロ" id="dbg-マクロ">dbg! マクロ</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<!--
The `dbg!` macro provides a nicer experience for debugging than `println!`:
-->
<p><code>dbg!</code>マクロは <code>println!</code>よりも、より良いデバッグ体験を提供します。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    dbg!(x);
}
</code></pre></pre>
<!--
If you run this program, you'll see:
-->
<p>このプログラムを実行すると、次の出力が表示されます。</p>
<pre><code class="language-text">[src/main.rs:4] x = 5
</code></pre>
<!--
You get the file and line number of where this was invoked, as well as the
name and value. Additionally, `println!` prints to the standard output, so you
really should be using `eprintln!` to print to standard error. `dbg!` does the
right thing and goes to stderr.
-->
<p>これを見ると、このマクロが呼ばれたソースコードファイル名、行番号とともに、変数名とその値が表示されているのがわかります。
さらに、<code>println!</code>は標準出力に出力するので、標準エラーに出力するためには<code>eprintln!</code>を使う必要がありますが、<code>dbg!</code>は正しく標準エラーに出力を行います。</p>
<!--
It even works in more complex circumstances. Consider this factorial example:
-->
<p><code>dbg!</code>マクロは、より複雑な状況でも動作します。以下の階乗の例を考えてみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factorial(n: u32) -&gt; u32 {
    if n &lt;= 1 {
        n
    } else {
        n * factorial(n - 1)
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
If we wanted to debug this, we might write it like this with `eprintln!`:
-->
<p>これをデバッグしたい場合、<code>eprintln!</code>を使ってこのように書くかも知れません。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factorial(n: u32) -&gt; u32 {
    eprintln!(&quot;n: {}&quot;, n);

    if n &lt;= 1 {
        eprintln!(&quot;n &lt;= 1&quot;);

        n
    } else {
        let n = n * factorial(n - 1);

        eprintln!(&quot;n: {}&quot;, n);

        n
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
We want to log `n` on each iteration, as well as have some kind of context
for each of the branches. We see this output for `factorial(4)`:
 -->
<p>ここでは、各反復で<code>n</code>の値と、場合分けのコンテキストを記録したいのですが、 <code>factorial(4)</code>を実行すると以下の出力が得られます。</p>
<pre><code class="language-text">n: 4
n: 3
n: 2
n: 1
n &lt;= 1
n: 2
n: 6
n: 24
</code></pre>
<!--
This is servicable, but not particularly great. Maybe we could work on how we
print out the context to make it more clear, but now we're not debugging our
code, we're figuring out how to make our debugging code better.
-->
<p>これは使えなくはないですが、特別に良いということでもありません。
コンテキストをより明確に表示するのに工夫することはできるでしょうが、ここではコードのデバッグをしているのではなく、デバッグ用のコードをより良くする方法を探そうとしています。</p>
<!--
Consider this version using `dbg!`:
-->
<p><code>dbg!</code>を使ったこのバージョンを考えてみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factorial(n: u32) -&gt; u32 {
    if dbg!(n &lt;= 1) {
        dbg!(1)
    } else {
        dbg!(n * factorial(n - 1))
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
We simply wrap each of the various expressions we want to print with the macro. We get this output instead:
 -->
<p>ここでは、表示したい幾つかの式を単純にマクロで囲っています。
これを実行するとこのような出力が得られます。</p>
<pre><code class="language-text">[src/main.rs:3] n &lt;= 1 = false
[src/main.rs:3] n &lt;= 1 = false
[src/main.rs:3] n &lt;= 1 = false
[src/main.rs:3] n &lt;= 1 = true
[src/main.rs:4] 1 = 1
[src/main.rs:5] n * factorial(n - 1) = 2
[src/main.rs:5] n * factorial(n - 1) = 6
[src/main.rs:5] n * factorial(n - 1) = 24
[src/main.rs:11] factorial(4) = 24
</code></pre>
<!--
Because the `dbg!` macro returns the value of what it's debugging, instead of
`eprintln!` which returns `()`, we need to make no changes to the structure of
our code. Additionally, we have vastly more useful output.
-->
<p><code>eprintln!</code>は常に<code>()</code>を返しますが、<code>dbg!</code>マクロは与えられた式の値を返すので、コードの構成を変える必要がありません。
加えて、表示結果にとても役に立つ情報が含まれています。</p>
<!--
# No jemalloc by default
-->
<h1><a class="header" href="#デフォルトでjemallocを使わない" id="デフォルトでjemallocを使わない">デフォルトでjemallocを使わない</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<!--
Long, long ago, Rust had a large, Erlang-like runtime. We chose to use
jemalloc instead of the system allocator, because it often improved
performance over the default system one. Over time, we shed more and more of
this runtime, and eventually almost all of it was removed, but jemalloc was
not. We didn't have a way to choose a custom allocator, and so we couldn't
really remove it without causing a regression for people who do need
jemalloc.
 -->
<p>遠い遠い昔、RustはErlang風のとても大きなランタイムを持っていました。
その際、性能面での改善が得られていたので、システムの標準のアロケータではなく、jemallocを使うという選択をしました。
それ以来、我々はランタイムの機能を徐々に削ぎ落とし、最終的にはほとんど何もなくなりましたが、jemallocは残されていました。
カスタムのアロケータを選ぶ方法がなく、jemallocを必要としている人に影響を与えることなくそれを削除することが出来なかったからです。</p>
<!--
Also, saying that jemalloc was always the default is a bit UNIX-centric, as
it was only the default on some platforms. Notably, the MSVC target on
Windows has shipped the system allocator for a long time.
-->
<p>さらに、jemallocは特定のプラットフォームでのみデフォルトなので、それが常にデフォルトだと言うのはややUnix偏重主義でしょう。
特にWindows上のMSVCターゲットは、長い間、システムのアロケータで出荷されています。</p>
<!--
While jemalloc usually has great performance, that's not always the case.
Additionally, it adds about 300kb to every Rust binary. We've also had a host
of other issues with jemalloc in the past. It has also felt a little strange
that a systems language does not default to the system's allocator.
-->
<p>jemallocは通常とても良い性能を出しますが、常にというわけではありません。
加えて、jemallocを使うとRustのすべてのバイナリーが300kb大きくなります。
そして、過去にはjemallocにまつわる問題が多くありました。
また、システム言語であるRustが、システムが提供するアロケータを使わないのは少し変だとも考えられていました。</p>
<!--
For all of these reasons, once Rust 1.28 shipped a way to choose a global
allocator, we started making plans to switch the default to the system
allocator, and allow you to use jemalloc via a crate. In Rust 1.32, we've
finally finished this work, and by default, you will get the system allocator
for your programs.
-->
<p>これらの理由により、Rust 1.28でグローバルアロケーターを選択できるようになってから、我々はシステムの提供するアロケータをデフォルトにして、jemallocはクレートを通じて使えるようにする計画を立て始めました。
Rust 1.32でこれが完成し、それぞれのプラットフォームでシステムが提供するアロケータがデフォルトで使われるようになりました。</p>
<!--
If you'd like to continue to use jemalloc, use the jemallocator crate. In
your Cargo.toml:
-->
<p>もしjemallocを使い続けたいのであれば、jemallocatorクレートを使ってください。
あなたのCargo.tomlに以下のように書き、</p>
<pre><code class="language-toml">jemallocator = &quot;0.1.8&quot;
</code></pre>
<!--
And in your crate root:
-->
<p>あなたのクレートのルートで以下のように書きます。</p>
<pre><code class="language-rust ignore">#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;
</code></pre>
<!--
That's it! If you don't need jemalloc, it's not forced upon you, and if you
do need it, it's a few lines of code away.
-->
<p>これだけです。あなたがjemallocを必要としていなければ強制されませんし、もし必要であれば数行追加するだけです。</p>
<!--
# Uniform Paths
-->
<h1><a class="header" href="#統一的なパス" id="統一的なパス">統一的なパス</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<!--
Rust 2018 added several improvements to the module system. We have one last
tweak landing in 1.32.0. Nicknamed "uniform paths", it permits previously
invalid import path statements to be resolved exactly the same way as
non-import paths. For example:
-->
<p>Rust 2018でモジュールシステムに幾つかの改善が加えられましたが、Rust 1.32.0で最終的な微調整の変更を一つ入れています。
「統一的なパス」と呼ばれるこの機能により、以前は不正だったインポートパス文を、インポート以外のパスと同じ様に解釈できるようになりました。例えば、以下の例を考えます。</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Color {
    Red,
    Green,
    Blue,
}

use Color::*;
<span class="boring">}
</span></code></pre></pre>
<!--
This code did not previously compile, as use statements had to start with
`super`, `self`, or `crate`. Now that the compiler supports uniform paths,
this code will work, and do what you probably expect: import the variants of
the Color enum defined above the `use` statement.
-->
<p>以前は、use文は<code>super</code>、<code>self</code>あるいは<code>crate</code>で始まらなければならなかったので、このコードはコンパイル出来ませんでした。
今ではコンパイラーが統一的なパスをサポートするようになり、このコードはあなたの想像通りの動作をします。
つまり、<code>use</code>文の上で宣言されているColor列挙型のヴァリアントをインポートします。</p>
<!--
# literal macro matcher
-->
<h1><a class="header" href="#リテラルマクロマッチャ" id="リテラルマクロマッチャ">リテラルマクロマッチャ</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<!--
A new `literal` matcher was added for macros:
-->
<p>リテラル（<code>literal</code>）マッチャがマクロに付け加えられました。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! m {
    ($lt:literal) =&gt; {};
}

fn main() {
    m!(&quot;some string literal&quot;);
}
</code></pre></pre>
<!--
`literal` matches against literals of any type; string literals, numeric
literals, `char` literals.
-->
<p><code>literal</code>は、文字列リテラル、数値リテラル、文字リテラルなど、どんなタイプのリテラルにもマッチします。</p>
<!--
# ? operator in macros
-->
<h1><a class="header" href="#マクロ内の演算子" id="マクロ内の演算子">マクロ内の?演算子</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<!--
`macro_rules` macros can use `?`, like this:
-->
<p><code>macro_rules</code> マクロ内で、<code>?</code>演算子を以下のように使えます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! bar {
    ($(a)?) =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `?` will match zero or one repetitions of the pattern, similar to the
already-existing `*` for "zero or more" and `+` for "one or more."
-->
<p>既に利用可能な <code>*</code>演算子が「0回以上」、<code>+</code>演算子が「1回以上」の繰り返しパターンを表すのと同様に、<code>?</code>演算子は0もしくは1回のパターンを表します。</p>
<h1><a class="header" href="#const-fn" id="const-fn"><code>const fn</code></a></h1>
<!--
Initially added: ![Minimum Rust version: 1.31](https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" />で最初に導入されました。</p>
<!--
Expanded in many releases, see each aspect below for more details.
-->
<p>そしてその後のリリースで何度か拡張されています。詳細は以下を確認してください。</p>
<!--
A `const fn` allows you to execute code in a "const context." For example:
-->
<p><code>const fn</code>によりコードを「constコンテキスト」で実行することができます(訳注：つまり、コンパイル時に評価されます)。例を示します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn five() -&gt; i32 {
    5
}

const FIVE: i32 = five();
<span class="boring">}
</span></code></pre></pre>
<!--
You cannot execute arbitrary code; the reasons why boil down to "you can
destroy the type system." The details are a bit too much to put here, but the
core idea is that `const fn` started off allowing the absolutely minimal
subset of the language, and has slowly added more abilities over time.
Therefore, while you can create a `const fn` in Rust 1.31, you cannot do much
with it. This is why we didn't add `const fn` to the Rust 2018 section; it
truly didn't become useful until after the release of the 2018 edition. This
means that if you read this document top to bottom, the earlier versions may
describe restrictions that are relaxed in later versions.

-->
<p>const fnでは任意のコードを実行することは出来ません。
というのは、簡単に言うと型システムを壊してしまうことになるからです。
詳細はここでは述べませんが、<code>const fn</code>では最小限の言語サブセットのみを使えるところからスタートし、徐々に出来ることを増やしていく、というのが基本的な考え方です。
したがって、導入当初のRust 1.31では <code>const fn</code>関数を作ることは出来ましたが、実際に出来ることはほとんどありませんでした。
これが、<code>const fn</code>をRust 2018のセクションに含めなかった理由なのですが、実際、Rust 2018エディションのリリース時にはあまり使い物になりませんでした。
もしあなたがこのドキュメントを最初から最後まで読んだとすると、以前のバージョンで制約とされていた部分がその後のバージョンで緩和されていることがわかるでしょう。</p>
<!--
Additionally, this has allowed more and more of the standard library to be
made `const`, we won't put all of those changes here, but you should know
that it is becoming more `const` over time.
-->
<p>さらに付け加えると、<code>const fn</code>で利用できる表記方が増えるに従って、標準ライブラリの機能が<code>const</code>化されていっています。
ここではその変更の全てを述べることはしませんが、時とともに <code>const</code>化される部分が増えていくことは知っておいても良いでしょう。</p>
<!--
## Arithmetic and comparison operators on integers
-->
<h2><a class="header" href="#整数の算術演算および比較演算" id="整数の算術演算および比較演算">整数の算術演算および比較演算</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can do arithmetic on integer literals:
-->
<p>整数リテラルに対して算術演算をすることができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() -&gt; i32 {
    5 + 6
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Many boolean operators
-->
<h2><a class="header" href="#多くのブーリアン演算" id="多くのブーリアン演算">多くのブーリアン演算</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can use boolean operators other than `&&` and `||`, because they short-circut evaluation:
-->
<p>ブーリアン演算のほとんどが使えます。
例外は<code>&amp;&amp;</code>と<code>||</code>で、これらは短絡評価を行うので使えなくなっています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn mask(val: u8) -&gt; u8 {
    let mask = 0x0f;

    mask &amp; val
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Constructing arrays, structs, enums, and tuples
-->
<h2><a class="header" href="#配列構造体列挙型タプルの生成" id="配列構造体列挙型タプルの生成">配列、構造体、列挙型、タプルの生成</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can create arrays, structs, enums, and tuples:
-->
<p>配列、構造体、列挙型、タプルを生成することができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

enum Error {
    Incorrect,
    FileNotFound,
}

const fn foo() {
    let array = [1, 2, 3];

    let point = Point {
        x: 5,
        y: 10,
    };

    let error = Error::FileNotFound;

    let tuple = (1, 2, 3);
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Calls to other const fns
-->
<h2><a class="header" href="#他のconst関数の呼び出し" id="他のconst関数の呼び出し">他のconst関数の呼び出し</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can call `const fn` from a `const fn`:
-->
<p><code>const fn</code>から<code>const fn</code>を呼び出すことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() -&gt; i32 {
    5
}

const fn bar() -&gt; i32 {
    foo()
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Index expressions on arrays and slices
-->
<h2><a class="header" href="#配列やスライスの添字式" id="配列やスライスの添字式">配列やスライスの添字式</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can index into an array or slice:
-->
<p>配列やスライスに添え字アクセスできます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() -&gt; i32 {
    let array = [1, 2, 3];

    array[1]
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Field accesses on structs and tuples
-->
<h2><a class="header" href="#構造体やタプルのフィールドアクセス" id="構造体やタプルのフィールドアクセス">構造体やタプルのフィールドアクセス</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can access parts of a struct or tuple:
-->
<p>構造体やタプルの構成要素にアクセスできます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

const fn foo() {
    let point = Point {
        x: 5,
        y: 10,
    };

    let tuple = (1, 2, 3);

    point.x;
    tuple.0;
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Reading from constants
-->
<h2><a class="header" href="#定数読み出し" id="定数読み出し">定数読み出し</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can read from a constant:
-->
<p>定数の値を読み出せます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: i32 = 5;

const fn foo() -&gt; i32 {
    FOO
}
<span class="boring">}
</span></code></pre></pre>
<!--
Note that this is *only* `const`, not `static`.
-->
<p>読み出せるのは <code>const</code>指定された定数<em>のみ</em>で、<code>static</code>指定された変数は読み出せません。</p>
<!--
## & and * of references
-->
<h2><a class="header" href="#参照の--と-" id="参照の--と-">参照の &amp; と *</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can create and de-reference references:
-->
<p>参照を作ったり、参照外しをすることができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo(r: &amp;i32) {
    *r;

    &amp;5;
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Casts, except for raw pointer to integer casts
-->
<h2><a class="header" href="#キャストただし生ポインタから整数へのキャストは除く" id="キャストただし生ポインタから整数へのキャストは除く">キャスト。ただし生ポインタから整数へのキャストは除く</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You may cast things, except for raw pointers may not be casted to an integer:
-->
<p>キャストができます。
例外は生ポインタから整数へのキャスト。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() {
    let x: usize = 5;

    x as i32;
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Irrefutable destructuring patterns
-->
<h2><a class="header" href="#論駁不可能な分配パターン" id="論駁不可能な分配パターン">論駁不可能な分配パターン</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.33-brightgreen.svg" alt="Minimum Rust version: 1.33" /></p>
<!--
You can use irrefutable patterns that destructure values. For example:
-->
<p>論駁不可能なパターンで値を分配することができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo((x, y): (u8, u8)) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `foo` destructures the tuple into `x` and `y`. `if let` is another
place that uses irrefutable patterns.
-->
<p>ここで、<code>foo</code>はタプルの値を<code>x</code>と<code>y</code>に分配します。
<code>if let</code>でも同様に論駁不可能なパターンを使います。</p>
<!--
## `let` bindings
-->
<h2><a class="header" href="#let-束縛" id="let-束縛"><code>let</code> 束縛</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.33-brightgreen.svg" alt="Minimum Rust version: 1.33" /></p>
<!--
You can use both mutable and immutable `let` bindings:
-->
<p>ミュータブルとイミュータブルの双方の<code>let</code>束縛を使うことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() {
    let x = 5;
    let mut y = 10;
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Assignment
-->
<h2><a class="header" href="#代入" id="代入">代入</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.33-brightgreen.svg" alt="Minimum Rust version: 1.33" /></p>
<!--
You can use assignment and assignment operators:
-->
<p>代入と代入演算子を使うことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() {
    let mut x = 5;
    x = 10;
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Calling `unsafe fn`
-->
<h2><a class="header" href="#unsafe-fn-の呼び出し" id="unsafe-fn-の呼び出し"><code>unsafe fn</code> の呼び出し</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.33-brightgreen.svg" alt="Minimum Rust version: 1.33" /></p>
<!--
You can call an `unsafe fn` inside a `const fn`:
-->
<p><code>const fn</code>の中で<code>unsafe fn</code>を呼び出すことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const unsafe fn foo() -&gt; i32 { 5 }

const fn bar() -&gt; i32 {
    unsafe { foo() }
}
<span class="boring">}
</span></code></pre></pre>
<!--
# Pinning
-->
<h1><a class="header" href="#ピン留め" id="ピン留め">ピン留め</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.33-brightgreen.svg" alt="Minimum Rust version: 1.33" /></p>
<!--
Rust 1.33 introduced a new concept, implemented as two types: 
-->
<p>Rust 1.33で新しい概念が導入され、二つの型で実装されました。</p>
<!--
* [`Pin<P>`](https://doc.rust-lang.org/std/pin/struct.Pin.html), a wrapper
  around a kind of pointer which makes that pointer "pin" its value in place,
  preventing the value referenced by that pointer from being moved.
* [`Unpin`](https://doc.rust-lang.org/std/marker/trait.Unpin.html), types that
  are safe to be moved, even if they're pinned.
  -->
<ul>
<li><a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin&lt;P&gt;</code></a> ポインタ的なモノを包むラッパで、その値が動かないように「ピン留め」します。
それにより、そのポインタにより参照されている値がムーブされるのを防ぎます。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Unpin.html"><code>Unpin</code></a> ピン留めされていても安全にムーブできる型です。</li>
</ul>
<!--
Most users will not interact with pinning directly, and so we won't explain
more here. For the details, see the [documentation for
`std::pin`](https://doc.rust-lang.org/std/pin/index.html).
-->
<p>ほとんどのユーザはピン留めを直接扱うことは無いと思うので、これ以上の説明は控えます。
より詳細を知りたければ<a href="https://doc.rust-lang.org/std/pin/index.html"><code>std::pin</code>のドキュメンテーション</a>を見てください。</p>
<!--
What *is* useful to know about pinning is that it's a pre-requisite for
`async`/`await`. Folks who write async libraries may need to learn about
pinning, but folks using them generally shouldn't need to interact with this
feature at all.
-->
<p>ピン留めは<code>async</code> / <code>await</code>の前提条件になっているということは知っておくと良いでしょう。
非同期のライブラリを作成する人はピン留めを学んでおく必要があるかも知れませんが、そのライブラリを使うだけの人はこの機能に直接触れることは無いでしょう。</p>
<!--
# No more FnBox
-->
<h1><a class="header" href="#fnboxは不要に" id="fnboxは不要に">FnBoxは不要に</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.35-brightgreen.svg" alt="Minimum Rust version: 1.35" /></p>
<!--
The book used to have this code in Chapter 20, section 2:
-->
<p>かつて、この本の20章2節には以下のコードがありました。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;dyn FnBox + Send + 'static&gt;;
<span class="boring">}
</span></code></pre></pre>
<!--
Here, we define a new trait called `FnBox`, and then implement it for all
`FnOnce` closures. All the implementation does is call the closure. These
sorts of hacks were needed because a `Box<dyn FnOnce>` didn't implement
`FnOnce`. This was true for all three posibilities:
-->
<p>ここで、<code>FnBox</code>という新しいトレイトを定義し、全ての<code>FnOnce</code>クロージャに対して実装をしています。
そして全ての実装がクロージャを呼び出します。
このハックは、<code>Box&lt;dyn FnOnce&gt;</code> が<code>FnOnce</code>を実装していなかったので必要でした。
そしてこれは以下の3つのパターンで必要でした。</p>
<!--
* `Box<dyn Fn>` and `Fn`
* `Box<dyn FnMut>` and `FnMut`
* `Box<dyn FnOnce>` and `FnOnce`
-->
<ul>
<li><code>Box&lt;dyn Fn&gt;</code> と <code>Fn</code></li>
<li><code>Box&lt;dyn FnMut&gt;</code> と <code>FnMut</code></li>
<li><code>Box&lt;dyn FnOnce&gt;</code> と <code>FnOnce</code></li>
</ul>
<!--
However, as of Rust 1.35, these traits are implemented for these types,
and so the `FnBox` trick is no longer required. In the latest version of
the book, the `Job` type looks like this:
-->
<p>しかし、Rust 1.35からこれらのトレイトがこれらの型に実装されたので、<code>FnBox</code>トリックは必要なくなりました。
この本の最新版では<code>Job</code>型はこのようになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
<span class="boring">}
</span></code></pre></pre>
<!--
No need for all that other code.
-->
<p>これ以外のコードは不要です。</p>
<!--
# Alternative Cargo registries
-->
<h1><a class="header" href="#cargoレジストリが選択できるように" id="cargoレジストリが選択できるように">Cargoレジストリが選択できるように</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.34](https://img.shields.io/badge/Minimum%20Rust%20Version-1.34-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.34-brightgreen.svg" alt="Minimum Rust version: 1.34" />で最初に導入されました。</p>
<!--
For various reasons, you may not want to publish code to crates.io, but you
may want to share it with others. For example, maybe your company writes Rust
code that's not open source, but you'd still like to use these internal
packages.
-->
<p>自分のコードを他の人とシェアしたいけど、何らかの理由でcrates.ioには公開したくないということがあるかも知れません。
例えば、あなたの会社ではオープンソースではないRustのコードを書いていて、でもその内部パッケージを使いたいという場合です。</p>
<!--
Cargo supports alternative registries by settings in `.cargo/config`:
-->
<p>Cargoは<code>.cargo/config</code>に設定を入れることで別のレジストリをサポートします。</p>
<pre><code class="language-toml">[registries]
my-registry = { index = &quot;https://my-intranet:7878/git/index&quot; }
</code></pre>
<!--
When you want to depend on a package from another registry, you add that
in to your `Cargo.toml`:
-->
<p>そして、別のレジストリのパッケージに依存したい時は、<code>Cargo.toml</code>にそれを追加します。</p>
<pre><code class="language-toml">[dependencies]
other-crate = { version = &quot;1.0&quot;, registry = &quot;my-registry&quot; }
</code></pre>
<!--
To learn more, check out the [registries section of the Cargo
book](https://doc.rust-lang.org/nightly/cargo/reference/registries.html).
-->
<p>詳しく知りたい場合は、<a href="https://doc.rust-lang.org/nightly/cargo/reference/registries.html">Cargoブックのレジストリのセクション</a>を確認してみてください。</p>
<!--
# TryFrom and TryInto
-->
<h1><a class="header" href="#tryfromとtryinto" id="tryfromとtryinto">TryFromとTryInto</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.34](https://img.shields.io/badge/Minimum%20Rust%20Version-1.34-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.34-brightgreen.svg" alt="Minimum Rust version: 1.34" />で最初に導入されました。</p>
<!--
The [`TryFrom`](../../std/convert/trait.TryFrom.html) and
[`TryInto`](../../std/convert/trait.TryInto.html) traits are like the
[`From`](../../std/convert/trait.From.html) and
[`Into`](../../std/convert/trait.Into.html) traits, except that they return a
result, meaning that they may fail.
-->
<p><a href="rust-next/../../std/convert/trait.TryFrom.html"><code>TryFrom</code></a>と<a href="rust-next/../../std/convert/trait.TryInto.html"><code>TryInto</code></a>トレイトは<a href="rust-next/../../std/convert/trait.From.html"><code>From</code></a>と<a href="rust-next/../../std/convert/trait.Into.html"><code>Into</code></a>トレイトと似ていますが、Result型を返すという点で異なっています。
つまり、これらの呼び出しは失敗することがあります。</p>
<!--
For example, the `from_be_bytes` and related methods on integer types take
arrays, but data is often read in via slices. Converting between slices and
arrays is tedious to do manually. With the new traits, it can be done inline
with `.try_into()`:
-->
<p>例えば、整数型の<code>from_be_bytes</code>や関連するメソッドは配列を引数に取りますが、そのデータはスライスから読み込まれるということがよくあります。スライスから配列への変換は手動でやると退屈なものです。
このトレイトを使えば、<code>try_into()</code>でインラインでできます。</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryInto;
<span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">let slice = &amp;[1, 2, 3, 4][..];
</span>let num = u32::from_be_bytes(slice.try_into()?);
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<!--
# The Future trait
-->
<h1><a class="header" href="#futureトレイト" id="futureトレイト">Futureトレイト</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.36](https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg" alt="Minimum Rust version: 1.36" />で最初に導入されました。</p>
<!--
In Rust 1.36.0 the long awaited [`Future`] trait has been stabilized!
-->
<p>Rust 1.36.0で長い間、待たれていた<a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>トレイトが安定化されました。</p>
<!--
TODO: this will probably be folded into a larger async section once we're
closer to the next edition.
-->
<p>TODO: 次のエディションに近づいたら、このページはおそらく大きな非同期セクションの中に織り込まれるでしょう。</p>
<!--
# The alloc crate
-->
<h1><a class="header" href="#allocクレート" id="allocクレート">allocクレート</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.36](https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg" alt="Minimum Rust version: 1.36" />で最初に導入されました。</p>
<!--
Before 1.36.0, the standard library consisted of the crates `std`, `core`, and `proc_macro`.
The `core` crate provided core functionality such as `Iterator` and `Copy`
and could be used in `#![no_std]` environments since it did not impose any requirements.
Meanwhile, the `std` crate provided types like `Box<T>` and OS functionality
but required a global allocator and other OS capabilities in return.
-->
<p>1.36.0以前は、 標準ライブラリは<code>std</code>、<code>core</code>、<code>proc_macro</code>クレートで構成されていました。
<code>core</code>クレートは<code>Iterator</code>や<code>Copy</code>のような主要機能を提供し、何も前提条件がなかったので<code>#![no_std]</code>環境で使うことができました。
一方、<code>std</code>クレートは<code>Box&lt;T&gt;</code>のような型やOSの機能を提供していましたが、その代わりにグローバルアロケータやその他のOSの機能を必要としていました。</p>
<!--
Starting with Rust 1.36.0, the parts of `std` that depend on a global allocator, e.g. `Vec<T>`,
are now available in the `alloc` crate. The `std` crate then re-exports these parts.
While `#![no_std]` *binaries* using `alloc` still require nightly Rust,
`#![no_std]` *library* crates can use the `alloc` crate in stable Rust.
Meanwhile, normal binaries, without `#![no_std]`, can depend on such library crates.
We hope this will facilitate the development of a `#![no_std]` compatible ecosystem of libraries
prior to stabilizing support for `#![no_std]` binaries using `alloc`.
-->
<p>Rust 1.36.0,から、<code>std</code>の中で、<code>Vec&lt;T&gt;</code>のようなグローバルアロケータに依存している部分は<code>alloc</code>クレートで提供されるようになりました。
<code>std</code>クレートはこれらを再公開します。
<code>alloc</code>を使う<code>#![no_std]</code>の<em>バイナリ</em>はまだnightly版のRustを必要としますが、<code>#![no_std]</code><em>ライブラリ</em>クレートは安定版のRustで<code>alloc</code>クレートを使うことができます。
一方で、<code>#![no_std]</code>ではない通常のバイナリはそのようなライブラリクレートに依存することが可能です。
これにより、<code>alloc</code>を使う<code>#![no_std]</code>バイナリのサポートが安定化する前に、<code>#![no_std]</code>互換のライブラリエコシステムの開発が進むことを期待しています。</p>
<!--
If you are the maintainer of a library that only relies on some allocation primitives to function,
consider making your library `#[no_std]` compatible by using the following at the top of your `lib.rs` file:
-->
<p>もしあなたが幾つかのアロケーションプリミティブのみに依存するライブラリのメンテナだったら、以下をあなたの<code>lib.rs</code>の先頭に入れて、<code>#[no_std]</code>互換にすることを検討してみてください。</p>
<pre><code class="language-rust ignore">#![no_std]

extern crate alloc;

use alloc::vec::Vec;
</code></pre>
<h1><a class="header" href="#maybeuninit" id="maybeuninit">MaybeUninit</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.36](https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg" alt="Minimum Rust version: 1.36" />で最初に導入されました。</p>
<!--
In previous releases of Rust, the [`mem::uninitialized`] function has allowed
you to bypass Rust's initialization checks by pretending that you've
initialized a value at type `T` without doing anything. One of the main uses
of this function has been to lazily allocate arrays.
-->
<p>以前のリリースのRustでは、<a href="https://doc.rust-lang.org/std/mem/fn.uninitialized.html"><code>mem::uninitialized</code></a>関数により、何もせずに型Tの値を初期化したように見せかけて、Rustの初期化チェックをバイパスすることができました。
この関数の主要な使い道の一つは配列の遅延アロケートでした。</p>
<!--
However, [`mem::uninitialized`] is an incredibly dangerous operation that
essentially cannot be used correctly as the Rust compiler assumes that values
are properly initialized. For example, calling `mem::uninitialized::<bool>()`
causes *instantaneous __undefined behavior__* as, from Rust's point of view,
the uninitialized bits are neither `0` (for `false`) nor `1` (for `true`) -
the only two allowed bit patterns for `bool`.
-->
<p>しかし、Rustコンパイラは値が正しく初期化されることを想定しているので、<a href="https://doc.rust-lang.org/std/mem/fn.uninitialized.html"><code>mem::uninitialized</code></a>関数は、本質的に正しく使うことができない、とても危険な操作です。
例えば、<code>mem::uninitialized::&lt;bool&gt;()</code>の呼び出しは<em>即時の__未定義動作__</em> を引き起こします。
なぜならば、Rustの視点からは、初期化されていないビットは<code>bool</code>の取り得る二つの値である、<code>0</code> (<code>false</code>) でも <code>1</code> (<code>true</code>) でもないからです。</p>
<!--
To remedy this situation, in Rust 1.36.0, the type [`MaybeUninit<T>`] has
been stabilized. The Rust compiler will understand that it should not assume
that a [`MaybeUninit<T>`] is a properly initialized `T`. Therefore, you can
do gradual initialization more safely and eventually use `.assume_init()`
once you are certain that `maybe_t: MaybeUninit<T>` contains an initialized
`T`.
-->
<p>この状況を是正するために、Rust 1.36.0で<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a>型が安定化されました。
Rustコンパイラは、<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a>は<code>T</code>が正しく初期化されると仮定できないことを理解しています。
したがって、段階的な初期化をより安全に行うことができ、<code>maybe_t: MaybeUninit&lt;T&gt;</code>が初期化された<code>T</code>を含んでいることが確実になったら、 <code>.assume_init()</code>を呼び出します。</p>
<!--
As [`MaybeUninit<T>`] is the safer alternative, starting with Rust 1.39, the
function [`mem::uninitialized`] will be deprecated.
-->
<p><a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a>はより安全な代替手段であるため、Rust 1.39から、<a href="https://doc.rust-lang.org/std/mem/fn.uninitialized.html"><code>mem::uninitialized</code></a>関数は非推奨となります。</p>
<h1><a class="header" href="#cargo-vendor" id="cargo-vendor">cargo vendor</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.37](https://img.shields.io/badge/Minimum%20Rust%20Version-1.37-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.37-brightgreen.svg" alt="Minimum Rust version: 1.37" />で最初に導入されました。</p>
<!--
After being available [as a separate crate][vendor-crate] for years, the `cargo vendor` command is now integrated directly into Cargo. The command fetches all your project's dependencies unpacking them into the `vendor/` directory, and shows the configuration snippet required to use the vendored code during builds.
-->
<p>長年、<a href="https://crates.io/crates/cargo-vendor">別のクレート</a>として提供されてきたのちに、<code>cargo vendor</code>コマンドがCargoに直接統合されました。
このコマンドはあなたのプロジェクトの依存関係を全て取ってきて、<code>vendor/</code>ディレクトリの下に展開します。
そして、ビルド時にベンダーコードを使うために必要なコンフィグレーションの断片表示します。</p>
<!--
There are multiple cases where `cargo vendor` is already used in production: the Rust compiler `rustc` uses it to ship all its dependencies in release tarballs, and projects with monorepos use it to commit the dependencies' code in source control.
-->
<p><code>cargo vendor</code>が既に使われている例が幾つかあります。
<code>rustc</code>コンパイラは全ての依存ライブラリをリリースアーカイブに入れるのに使い、モノリポのプロジェクトは依存コードをソースコード管理ツールにコミットするのに使っています。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
