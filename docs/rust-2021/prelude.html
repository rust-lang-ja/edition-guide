<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Prelude への追加 - エディションガイド</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/em-to-bold.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">序文</a></li><li class="chapter-item expanded "><a href="../editions/index.html"><strong aria-hidden="true">1.</strong> エディションとは？</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../editions/creating-a-new-project.html"><strong aria-hidden="true">1.1.</strong> 新しいプロジェクトを作成する</a></li><li class="chapter-item expanded "><a href="../editions/transitioning-an-existing-project-to-a-new-edition.html"><strong aria-hidden="true">1.2.</strong> 既存のプロジェクトのエディションを移行する</a></li><li class="chapter-item expanded "><a href="../editions/advanced-migrations.html"><strong aria-hidden="true">1.3.</strong> 発展的な移行戦略</a></li></ol></li><li class="chapter-item expanded "><a href="../rust-2015/index.html"><strong aria-hidden="true">2.</strong> Rust 2015</a></li><li class="chapter-item expanded "><a href="../rust-2018/index.html"><strong aria-hidden="true">3.</strong> Rust 2018</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust-2018/path-changes.html"><strong aria-hidden="true">3.1.</strong> パスとモジュールシステムへの変更</a></li><li class="chapter-item expanded "><a href="../rust-2018/trait-fn-parameters.html"><strong aria-hidden="true">3.2.</strong> トレイト関数の匿名パラメータの非推奨化</a></li><li class="chapter-item expanded "><a href="../rust-2018/new-keywords.html"><strong aria-hidden="true">3.3.</strong> 新しいキーワード</a></li><li class="chapter-item expanded "><a href="../rust-2018/tyvar-behind-raw-pointer.html"><strong aria-hidden="true">3.4.</strong> 推論変数への生ポインタに対するメソッドのディスパッチ</a></li><li class="chapter-item expanded "><a href="../rust-2018/cargo.html"><strong aria-hidden="true">3.5.</strong> Cargo への変更</a></li></ol></li><li class="chapter-item expanded "><a href="../rust-2021/index.html"><strong aria-hidden="true">4.</strong> Rust 2021</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust-2021/prelude.html" class="active"><strong aria-hidden="true">4.1.</strong> Prelude への追加</a></li><li class="chapter-item expanded "><a href="../rust-2021/default-cargo-resolver.html"><strong aria-hidden="true">4.2.</strong> デフォルトの Cargo のフィーチャリゾルバ</a></li><li class="chapter-item expanded "><a href="../rust-2021/IntoIterator-for-arrays.html"><strong aria-hidden="true">4.3.</strong> 配列に対する IntoIterator</a></li><li class="chapter-item expanded "><a href="../rust-2021/disjoint-capture-in-closures.html"><strong aria-hidden="true">4.4.</strong> クロージャはフィールドごとにキャプチャする</a></li><li class="chapter-item expanded "><a href="../rust-2021/panic-macro-consistency.html"><strong aria-hidden="true">4.5.</strong> panic マクロの一貫性</a></li><li class="chapter-item expanded "><a href="../rust-2021/reserving-syntax.html"><strong aria-hidden="true">4.6.</strong> 構文の予約</a></li><li class="chapter-item expanded "><a href="../rust-2021/warnings-promoted-to-error.html"><strong aria-hidden="true">4.7.</strong> 警告からエラーへの格上げ</a></li><li class="chapter-item expanded "><a href="../rust-2021/or-patterns-macro-rules.html"><strong aria-hidden="true">4.8.</strong> マクロ規則における OR パターン</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">エディションガイド</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-ja/edition-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Additions to the prelude
-->
<h1 id="prelude-への追加"><a class="header" href="#prelude-への追加">Prelude への追加</a></h1>
<!--
## Summary
-->
<h2 id="概要"><a class="header" href="#概要">概要</a></h2>
<!--
- The `TryInto`, `TryFrom` and `FromIterator` traits are now part of the prelude.
- This might make calls to trait methods ambiguous which could make some code fail to compile.
-->
<ul>
<li><code>TryInto</code>, <code>TryFrom</code>, <code>FromIterator</code> トレイトがプレリュードに追加されました。</li>
<li>これにより、トレイトメソッドへの呼び出しに曖昧性が発生して、コンパイルに失敗するようになるコードがあるかもしれません。</li>
</ul>
<!--
## Details
-->
<h2 id="詳細"><a class="header" href="#詳細">詳細</a></h2>
<!--
The [prelude of the standard library](https://doc.rust-lang.org/stable/std/prelude/index.html)
is the module containing everything that is automatically imported in every module.
It contains commonly used items such as `Option`, `Vec`, `drop`, and `Clone`.
-->
<p><a href="https://doc.rust-lang.org/stable/std/prelude/index.html">標準ライブラリの prelude</a> モジュールには、
すべてのモジュールにインポートされるものが余すことなく定義されています。
そこには、<code>Option</code>, <code>Vec</code>, <code>drop</code>, <code>Clone</code> などの、頻繁に使われるアイテムが含まれます。</p>
<!--
The Rust compiler prioritizes any manually imported items over those
from the prelude, to make sure additions to the prelude will not break any existing code.
For example, if you have a crate or module called `example` containing a `pub struct Option;`,
then `use example::*;` will make `Option` unambiguously refer to the one from `example`;
not the one from the standard library.
-->
<p>Rust コンパイラは、手動で<!-- TODO: 明示的に、のほうがいいか？-->インポートされたアイテムをプレリュードからのものより優先します。
これにより、プレリュードに追加があっても既存のコードは壊れないようになっています。
たとえば、 <code>example</code> という名前のクレートまたはモジュールに <code>pub struct Option;</code> が含まれていたら、
<code>use example::*;</code> とすることで <code>Option</code> は曖昧性なく <code>example</code> に含まれるものを指し示し、
標準ライブラリのものは指しません。</p>
<!--
However, adding a _trait_ to the prelude can break existing code in a subtle way.
For example, a call to `x.try_into()` which comes from a `MyTryInto` trait might fail 
to compile if `std`'s `TryInto` is also imported, because the call to `try_into` is now 
ambiguous and could come from either trait. This is the reason we haven't added `TryInto` 
to the prelude yet, since there is a lot of code that would break this way.
-->
<p>ところが、<em>トレイト</em><!-- -->をプレリュードに追加すると、捉えがたい形でコードが壊れることがあります。
たとえば、<code>MyTryInto</code> トレイトで定義されている <code>x.try_into()</code> という呼び出しは、
<code>std</code> の <code>TryInto</code> もインポートされているときは、動かなくなる場合があります。
なぜなら、<code>try_into</code> の呼び出しは今や曖昧で、どちらのトレイトから来ているかわからないからです。
だからこそ我々は、 <code>TryInto</code> を未だにプレリュードに追加していませんでした。
追加してしまうと、多くのコードでそのような問題が起こりうるからです。</p>
<!--
As a solution, Rust 2021 will use a new prelude.
It's identical to the current one, except for three new additions:
-->
<p>解決策として、Rust 2021 では新たなプレリュードが使用されます。
変更点は、以下の3つが追加されたということだけです。</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html"><code>std::convert::TryInto</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html"><code>std::convert::TryFrom</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html"><code>std::iter::FromIterator</code></a></li>
</ul>
<!--
The tracking issue [can be found here](https://github.com/rust-lang/rust/issues/85684).
-->
<p>追跡用の Issue は<a href="https://github.com/rust-lang/rust/issues/85684">こちら</a>です。</p>
<!--
## Migration 
-->
<h2 id="移行"><a class="header" href="#移行">移行</a></h2>
<!--
As a part of the 2021 edition a migration lint, `rust_2021_prelude_collisions`, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.
-->
<p>Rust 2018 コードベースから Rust 2021 への自動移行の支援のため、2021 エディションには、移行用のリント<code>rust_2021_prelude_collisions</code> が追加されています。</p>
<!--
In order to have `rustfix` migrate your code to be Rust 2021 Edition compatible, run:
-->
<p><code>rustfix</code> でコードを Rust 2021 エディションに適合させるためには、次のように実行します。</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<!--
The lint detects cases where functions or methods are called that have the same name as the methods defined in one of the new prelude traits. In some cases, it may rewrite your calls in various ways to ensure that you continue to call the same function you did before.
-->
<p>このリントは、新しくプレリュードに追加されたトレイトで定義されているメソッドと同名の関数やメソッドが呼び出されていることを検知します。
場合によっては、今までと同じ関数が呼び出されるように、あなたのコードを様々な方法で書き換えることもあります。</p>
<!--
If you'd like to migrate your code manually or better understand what `rustfix` is doing, below we've outlined the situations where a migration is needed along with a counter example of when it's not needed.
-->
<p>コードの移行を手作業で行いたい方や <code>rustfix</code> が何を行うかをより詳しく理解したい方のために、どのような状況で移行が必要なのか、逆にどうであれば不要なのを以下に例示していきます。</p>
<!--
### Migration needed
-->
<h3 id="移行が必要な場合"><a class="header" href="#移行が必要な場合">移行が必要な場合</a></h3>
<!--
#### Conflicting trait methods
-->
<h4 id="トレイトメソッドの衝突"><a class="header" href="#トレイトメソッドの衝突">トレイトメソッドの衝突</a></h4>
<!--
When two traits that are in scope have the same method name, it is ambiguous which trait method should be used. For example:
-->
<p>あるスコープに、同じメソッド名を持つ2つのトレイトがある場合、どちらのメソッドが使用されるべきかは曖昧です。例えば：</p>
<pre><pre class="playground"><code class="language-rust">trait MyTrait&lt;A&gt; {
  // This name is the same as the `from_iter` method on the `FromIterator` trait from `std`.  
  // この関数名は、`std` の `FromIterator` トレイトの `from_iter` メソッドと同名。
  fn from_iter(x: Option&lt;A&gt;);
}

impl&lt;T&gt; MyTrait&lt;()&gt; for Vec&lt;T&gt; {
  fn from_iter(_: Option&lt;()&gt;) {}
}

fn main() {
  // Vec&lt;T&gt; implements both `std::iter::FromIterator` and `MyTrait` 
  // If both traits are in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `from_iter` method to call
  // Vec&lt;T&gt; は `std::iter::FromIterator` と `MyTrait` の両方を実装する
  // もし両方のトレイトがスコープに含まれる場合 (Rust 2021 ではそうであるが)、
  // どちらの `from_iter` メソッドを呼び出せばいいかが曖昧になる
  &lt;Vec&lt;i32&gt;&gt;::from_iter(None);
}
</code></pre></pre>
<!--
We can fix this by using fully qualified syntax:
-->
<p>完全修飾構文を使うと、これを修正できます:</p>
<pre><code class="language-rust ignore">fn main() {
  // Now it is clear which trait method we're referring to
  // こうすれば、どちらのトレイトメソッドを指し示しているかが明確になる
  &lt;Vec&lt;i32&gt; as MyTrait&lt;()&gt;&gt;::from_iter(None);
}
</code></pre>
<!--
#### Inherent methods on `dyn Trait` objects
-->
<h4 id="dyn-trait-オブジェクトの固有メソッド"><a class="header" href="#dyn-trait-オブジェクトの固有メソッド"><code>dyn Trait</code> オブジェクトの固有メソッド</a></h4>
<!--
Some users invoke methods on a `dyn Trait` value where the method name overlaps with a new prelude trait:
-->
<p><code>dyn Trait</code> の値に対してメソッドを呼び出すときに、メソッド名が新しくプレリュードに追加されたトレイトと重複していることがあります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod submodule {
  pub trait MyTrait {
    // This has the same name as `TryInto::try_into`
    // これは `TryInto::try_into` と同名
    fn try_into(&amp;self) -&gt; Result&lt;u32, ()&gt;;
  }
}

// `MyTrait` isn't in scope here and can only be referred to through the path `submodule::MyTrait`
// `MyTrait` はここではスコープ内になく、パス付きで `submodule::MyTrait` としか利用できない
fn bar(f: Box&lt;dyn submodule::MyTrait&gt;) {
  // If `std::convert::TryInto` is in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `try_into` method to call
  // `std::convert::TryInto` がスコープ内にあるときは (Rust 2021 ではそうなのだが)、
  // どちらの `try_into` メソッドを呼び出せばいいかが曖昧になる
  f.try_into();
}
<span class="boring">}
</span></code></pre></pre>
<!--
Unlike with static dispatch methods, calling a trait method on a trait object does not require that the trait be in scope. The code above works 
as long as there is no trait in scope with a conflicting method name. When the `TryInto` trait is in scope (which is the case in Rust 2021),
this causes an ambiguity. Should the call be to `MyTrait::try_into` or `std::convert::TryInto::try_into`?
-->
<p>静的ディスパッチのときと違って、トレイトオブジェクトに対してトレイトメソッドを呼び出すときは、そのトレイトがスコープ内にある必要はありません。
<code>TryInto</code> トレイトがスコープ内にあるときは (Rust 2021 ではそうなのですが)、曖昧性が発生します。
<code>MyTrait::try_into</code> と <code>std::convert::TryInto::try_into</code> のどちらが呼び出されるべきなのでしょうか？</p>
<!--
In these cases, we can fix this by adding an additional dereferences or otherwise clarify the type of the method receiver. This ensures that 
the `dyn Trait` method is chosen, versus the methods from the prelude trait. For example, turning `f.try_into()` above into `(&*f).try_into()` 
ensures that we're calling `try_into` on the `dyn MyTrait` which can only refer to the `MyTrait::try_into` method.
-->
<p>この場合、さらなる参照外しをするか、もしくはメソッドレシーバーの型を明示することで修正できます。
これにより、<code>dyn Trait</code> のメソッドとプレリュードのトレイトのメソッドのどちらが選ばれているかが明確になります。
たとえば、上の <code>f.try_into()</code> を <code>(&amp;*f).try_into()</code> にすると、<code>try_into</code> が <code>dyn Trait</code> に対して呼び出されることがはっきりします。
これに該当するのは<code>MyTrait::try_into</code>メソッドのみです。</p>
<!--
### No migration needed
-->
<h3 id="移行が不要な場合"><a class="header" href="#移行が不要な場合">移行が不要な場合</a></h3>
<!--
####  Inherent methods
-->
<h4 id="固有メソッド"><a class="header" href="#固有メソッド">固有メソッド</a></h4>
<!--
Many types define their own inherent methods with the same name as a trait method. For instance, below the struct `MyStruct` implements `from_iter` which shares the same name with the method from the trait `FromIterator` found in the standard library:
-->
<p>トレイトメソッドと同名の固有メソッドを定義しているような型もたくさんあります。
たとえば、以下では <code>MyStruct</code> が <code>from_iter</code> を実装していますが、
これは標準ライブラリの <code>FromIterator</code> トレイトのメソッドと同名です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter::IntoIterator;

struct MyStruct {
  data: Vec&lt;u32&gt;
}

impl MyStruct {
  // This has the same name as `std::iter::FromIterator::from_iter`
  // これは `std::iter::FromIterator::from_iter` と同名
  fn from_iter(iter: impl IntoIterator&lt;Item = u32&gt;) -&gt; Self {
    Self {
      data: iter.into_iter().collect()
    }
  }
}

impl std::iter::FromIterator&lt;u32&gt; for MyStruct {
    fn from_iter&lt;I: IntoIterator&lt;Item = u32&gt;&gt;(iter: I) -&gt; Self {
      Self {
        data: iter.into_iter().collect()
      }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Inherent methods always take precedent over trait methods so there's no need for any migration.
-->
<p>固有メソッドは常にトレイトメソッドより優先されるため、移行作業の必要はありません。</p>
<!--
### Implementation Reference
-->
<h3 id="実装の参考事項"><a class="header" href="#実装の参考事項">実装の参考事項</a></h3>
<!--
The lint needs to take a couple of factors into account when determining whether or not introducing 2021 Edition to a codebase will cause a name resolution collision (thus breaking the code after changing edition). These factors include:
-->
<p>2021 エディションを導入することで名前解決に衝突が生じるかどうか（すなわち、エディションを変えることでコードが壊れるかどうか）を判断するために、このリントはいくつかの要素を考慮する必要があります。たとえば以下のような点です:</p>
<!--
- Is the call a [fully-qualified call] or does it use [dot-call method syntax]?
  - This will affect how the name is resolved due to auto-reference and auto-dereferencing on method call syntax. Manually dereferencing/referencing will allow specifying priority in the case of dot-call method syntax, while fully-qualified call requires specification of the type and the trait name in the method path (e.g. `<Type as Trait>::method`)
- Is this an [inherent method] or [a trait method]?
  - Inherent methods that take `self` will take priority over `TryInto::try_into` as inherent methods take priority over trait methods, but inherent methods that take `&self` or `&mut self` won't take priority due to requiring a auto-reference (while `TryInto::try_into` does not, as it takes `self`)
- Is the origin of this method from `core`/`std`? (As the traits can't have a collision with themselves)
- Does the given type implement the trait it could have a collision against?
- Is the method being called via dynamic dispatch? (i.e. is the `self` type `dyn Trait`)
  - If so, trait imports don't affect resolution, and no migration lint needs to occur
-->
<ul>
<li><a href="https://doc.rust-lang.org/reference/expressions/call-expr.html#disambiguating-function-calls">完全修飾呼び出し</a>と<a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html">ドット呼び出しメソッド構文</a>のどちらが使われているか？
<ul>
<li>これは、メソッド呼び出し構文の自動参照付けと自動参照外しによる名前の解決方法に影響します。ドット呼び出しメソッド構文では、手動で参照外し/参照付けすることで優先順位を決められますが、完全修飾呼び出しではメソッドパス中に型とトレイト名が指定されていなければなりません (例: <code>&lt;Type as Trait&gt;::method</code>)</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations">固有メソッド</a>と<a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementations">トレイトメソッド</a>のどちらが呼び出されているか？
<ul>
<li>固有メソッドはトレイトメソッドより優先されるので、<code>self</code> を取るトレイトメソッドは、<code>TryInto::try_into</code>より優先されますが、<code>&amp;self</code> や <code>&amp;mut self</code> をとる固有メソッドは、自動参照付けが必要なので優先されません（もっとも、<code>TryInto</code> は <code>self</code> を取るので、それは当てはまりませんが）</li>
</ul>
</li>
<li>そのメソッドは <code>core</code> か <code>std</code> から来たものか？　（トレイトは自分自身とは衝突しないので）</li>
<li>その型は、名前が衝突するようなトレイトを実装しているか？</li>
<li>メソッドが動的ディスパッチによって呼び出されているか？  （つまり、 <code>self</code> の型が <code>dyn Trait</code> か？）
<ul>
<li>その場合、トレイトのインポートは名前解決に影響しないので、移行リントを出す必要はありません</li>
</ul>
</li>
</ul>
<!--
[fully-qualified call]: https://doc.rust-lang.org/reference/expressions/call-expr.html#disambiguating-function-calls
[dot-call method syntax]: https://doc.rust-lang.org/reference/expressions/method-call-expr.html
[inherent method]: https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations
[a trait method]: https://doc.rust-lang.org/reference/items/implementations.html#trait-implementations
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rust-2021/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../rust-2021/default-cargo-resolver.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rust-2021/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../rust-2021/default-cargo-resolver.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
